# # outputs: "GEOID"
# Perform the important transformations to variables based on the type of number
if(grepl("pct", selected)) {
fill_text <- geom_text(aes(label = paste0(round(!!sym(selected), 1), '%')),
color = "white", size = 4)
} else {
fill_text <- geom_text(aes(label = paste0(scales::comma(round(!!sym(selected), -5)))), # rounds to nearest 100k
color = "white", size = 4)
}
title <- dict_vars$national_dropdown_label[which(dict_vars$var_readable == selected)][1]
legend_title <- dict_vars$var_pretty[which(dict_vars$var_readable == selected)][1]
breaks <- unname(quantile(data %>% pull(!!sym(selected))))
data %>%
ggplot(aes(x = 1, y = 1, # A tile map without x or y axis changes will fill out the tile for the state
fill = !!sym(selected))) + # Selected variable
geom_tile() + # Imports x and y values
fill_text +
labs(x = "", y = "", title = title) +
facet_geo(facets = ~ ABBR, grid = "us_state_with_DC_PR_grid2") +
theme(plot.background = element_rect(colour = "white"), # Removes all of the grid elements that we don't need
panel.grid = element_blank(),
panel.grid.major = element_blank(),
axis.text = element_blank(),
axis.ticks = element_blank(),
axis.line = element_blank(),
panel.spacing = unit(0L, "pt"),
legend.position = "bottom",
legend.text = element_text(angle = 45, vjust = .5),
strip.text.x = element_text(size = 9L)) +
scale_fill_binned(high = "#132B43", low = "#56B1F7", breaks = breaks) # reverses the default gradient direction so that dark blue is associated with larger values
}
render_tile_map(demographics, "pop_total")
breaks <- quantiles(demographics$pwd_total)
breaks <- quantile(demographics$pwd_total)
breaks
names(breaks) <- c(scales::comma(breaks))
breaks
render_tile_map <- function(data, selected) {
# ### Unnecessary if selected is being passed as a string
# # but we may want to pass the variable itself at some point
# selected_varname <- deparse(substitute(!!sym(selected))) %>% gsub("^[^\\$]*\\$", "", .)
# ### Parsing the regex
# # ^ anchor for beginning of string
# # [^\\$]* matches everything excluding "$" char
# # \\$ terminates match at "$" char
# # example: deparse(substitute(national_demographic_readable$GEOID)) %>% gsub("^[^\\$]*\\$", "", .)
# # outputs: "GEOID"
# Perform the important transformations to variables based on the type of number
if(grepl("pct", selected)) {
fill_text <- geom_text(aes(label = paste0(round(!!sym(selected), 1), '%')),
color = "white", size = 4)
breaks <- quantile(data %>% pull(!!sym(selected)))
names(breaks) <- c(scales::percent(breaks))
} else {
fill_text <- geom_text(aes(label = paste0(scales::comma(round(!!sym(selected), -5)))), # rounds to nearest 100k
color = "white", size = 4)
breaks <- quantile(data %>% pull(!!sym(selected)))
names(breaks) <- c(scales::comma(breaks))
}
title <- dict_vars$national_dropdown_label[which(dict_vars$var_readable == selected)][1]
legend_title <- dict_vars$var_pretty[which(dict_vars$var_readable == selected)][1]
data %>%
ggplot(aes(x = 1, y = 1, # A tile map without x or y axis changes will fill out the tile for the state
fill = !!sym(selected))) + # Selected variable
geom_tile() + # Imports x and y values
fill_text +
labs(x = "", y = "", title = title) +
facet_geo(facets = ~ ABBR, grid = "us_state_with_DC_PR_grid2") +
theme(plot.background = element_rect(colour = "white"), # Removes all of the grid elements that we don't need
panel.grid = element_blank(),
panel.grid.major = element_blank(),
axis.text = element_blank(),
axis.ticks = element_blank(),
axis.line = element_blank(),
panel.spacing = unit(0L, "pt"),
legend.position = "bottom",
legend.text = element_text(angle = 45, vjust = .5),
strip.text.x = element_text(size = 9L)) +
scale_fill_binned(high = "#132B43", low = "#56B1F7", breaks = breaks) # reverses the default gradient direction so that dark blue is associated with larger values
}
render_tile_map(demographics, "pop_total")
render_tile_map(demographics, "pwd_pct")
quantile(demographics$pwd_pct)
render_tile_map <- function(data, selected) {
# ### Unnecessary if selected is being passed as a string
# # but we may want to pass the variable itself at some point
# selected_varname <- deparse(substitute(!!sym(selected))) %>% gsub("^[^\\$]*\\$", "", .)
# ### Parsing the regex
# # ^ anchor for beginning of string
# # [^\\$]* matches everything excluding "$" char
# # \\$ terminates match at "$" char
# # example: deparse(substitute(national_demographic_readable$GEOID)) %>% gsub("^[^\\$]*\\$", "", .)
# # outputs: "GEOID"
# Perform the important transformations to variables based on the type of number
if(grepl("pct", selected)) {
fill_text <- geom_text(aes(label = paste0(round(!!sym(selected), 1), '%')),
color = "white", size = 4)
breaks <- quantile(data %>% pull(!!sym(selected)))
names(breaks) <- c(scales::percent(breaks / 100))
} else {
fill_text <- geom_text(aes(label = paste0(scales::comma(round(!!sym(selected), -5)))), # rounds to nearest 100k
color = "white", size = 4)
breaks <- quantile(data %>% pull(!!sym(selected)))
names(breaks) <- c(scales::comma(breaks))
}
title <- dict_vars$national_dropdown_label[which(dict_vars$var_readable == selected)][1]
legend_title <- dict_vars$var_pretty[which(dict_vars$var_readable == selected)][1]
data %>%
ggplot(aes(x = 1, y = 1, # A tile map without x or y axis changes will fill out the tile for the state
fill = !!sym(selected))) + # Selected variable
geom_tile() + # Imports x and y values
fill_text +
labs(x = "", y = "", title = title) +
facet_geo(facets = ~ ABBR, grid = "us_state_with_DC_PR_grid2") +
theme(plot.background = element_rect(colour = "white"), # Removes all of the grid elements that we don't need
panel.grid = element_blank(),
panel.grid.major = element_blank(),
axis.text = element_blank(),
axis.ticks = element_blank(),
axis.line = element_blank(),
panel.spacing = unit(0L, "pt"),
legend.position = "bottom",
legend.text = element_text(angle = 45, vjust = .5),
strip.text.x = element_text(size = 9L)) +
scale_fill_binned(high = "#132B43", low = "#56B1F7", breaks = breaks) # reverses the default gradient direction so that dark blue is associated with larger values
}
render_tile_map(demographics, "pwd_pct")
render_tile_map <- function(data, selected) {
# ### Unnecessary if selected is being passed as a string
# # but we may want to pass the variable itself at some point
# selected_varname <- deparse(substitute(!!sym(selected))) %>% gsub("^[^\\$]*\\$", "", .)
# ### Parsing the regex
# # ^ anchor for beginning of string
# # [^\\$]* matches everything excluding "$" char
# # \\$ terminates match at "$" char
# # example: deparse(substitute(national_demographic_readable$GEOID)) %>% gsub("^[^\\$]*\\$", "", .)
# # outputs: "GEOID"
# Perform the important transformations to variables based on the type of number
if(grepl("pct", selected)) {
fill_text <- geom_text(aes(label = paste0(round(!!sym(selected), 1), '%')),
color = "white", size = 4)
breaks <- quantile(data %>% pull(!!sym(selected)))
names(breaks) <- c(scales::percent(breaks / 100))
} else {
fill_text <- geom_text(aes(label = paste0(scales::comma(round(!!sym(selected), -5)))), # rounds to nearest 100k
color = "white", size = 4)
breaks <- quantile(data %>% pull(!!sym(selected)))
names(breaks) <- c(scales::comma(breaks))
}
title <- dict_vars$national_dropdown_label[which(dict_vars$var_readable == selected)][1]
legend_title <- dict_vars$var_pretty[which(dict_vars$var_readable == selected)][1]
data %>%
ggplot(aes(x = 1, y = 1, # A tile map without x or y axis changes will fill out the tile for the state
fill = !!sym(selected))) + # Selected variable
geom_tile() + # Imports x and y values
fill_text +
labs(x = "", y = "",
title = title,
fill = legend_title) +
facet_geo(facets = ~ ABBR, grid = "us_state_with_DC_PR_grid2") +
theme(plot.background = element_rect(colour = "white"), # Removes all of the grid elements that we don't need
panel.grid = element_blank(),
panel.grid.major = element_blank(),
axis.text = element_blank(),
axis.ticks = element_blank(),
axis.line = element_blank(),
panel.spacing = unit(0L, "pt"),
legend.position = "bottom",
legend.text = element_text(angle = 45, vjust = .5),
strip.text.x = element_text(size = 9L)) +
scale_fill_binned(high = "#132B43", low = "#56B1F7", breaks = breaks) # reverses the default gradient direction so that dark blue is associated with larger values
}
render_tile_map(demographics, "pwd_pct")
render_tile_map <- function(data, selected) {
# ### Unnecessary if selected is being passed as a string
# # but we may want to pass the variable itself at some point
# selected_varname <- deparse(substitute(!!sym(selected))) %>% gsub("^[^\\$]*\\$", "", .)
# ### Parsing the regex
# # ^ anchor for beginning of string
# # [^\\$]* matches everything excluding "$" char
# # \\$ terminates match at "$" char
# # example: deparse(substitute(national_demographic_readable$GEOID)) %>% gsub("^[^\\$]*\\$", "", .)
# # outputs: "GEOID"
# Perform the important transformations to variables based on the type of number
if(grepl("pct", selected)) {
fill_text <- geom_text(aes(label = paste0(round(!!sym(selected), 1), '%')),
color = "white", size = 4)
breaks <- quantile(data %>% pull(!!sym(selected)))[2:5]
names(breaks) <- c(scales::percent(breaks / 100))
} else {
fill_text <- geom_text(aes(label = paste0(scales::comma(round(!!sym(selected), -5)))), # rounds to nearest 100k
color = "white", size = 4)
breaks <- quantile(data %>% pull(!!sym(selected)))[2:5]
names(breaks) <- c(scales::comma(breaks))
}
title <- dict_vars$national_dropdown_label[which(dict_vars$var_readable == selected)][1]
legend_title <- dict_vars$var_pretty[which(dict_vars$var_readable == selected)][1]
data %>%
ggplot(aes(x = 1, y = 1, # A tile map without x or y axis changes will fill out the tile for the state
fill = !!sym(selected))) + # Selected variable
geom_tile() + # Imports x and y values
fill_text +
labs(x = "", y = "",
title = title,
fill = legend_title) +
facet_geo(facets = ~ ABBR, grid = "us_state_with_DC_PR_grid2") +
theme(plot.background = element_rect(colour = "white"), # Removes all of the grid elements that we don't need
panel.grid = element_blank(),
panel.grid.major = element_blank(),
axis.text = element_blank(),
axis.ticks = element_blank(),
axis.line = element_blank(),
panel.spacing = unit(0L, "pt"),
legend.position = "bottom",
legend.text = element_text(angle = 45, vjust = .5),
strip.text.x = element_text(size = 9L)) +
scale_fill_binned(high = "#132B43", low = "#56B1F7", breaks = breaks) # reverses the default gradient direction so that dark blue is associated with larger values
}
render_tile_map(demographics, "pwd_pct")
render_tile_map <- function(data, selected) {
# ### Unnecessary if selected is being passed as a string
# # but we may want to pass the variable itself at some point
# selected_varname <- deparse(substitute(!!sym(selected))) %>% gsub("^[^\\$]*\\$", "", .)
# ### Parsing the regex
# # ^ anchor for beginning of string
# # [^\\$]* matches everything excluding "$" char
# # \\$ terminates match at "$" char
# # example: deparse(substitute(national_demographic_readable$GEOID)) %>% gsub("^[^\\$]*\\$", "", .)
# # outputs: "GEOID"
# Perform the important transformations to variables based on the type of number
if(grepl("pct", selected)) {
fill_text <- geom_text(aes(label = paste0(round(!!sym(selected), 1), '%')),
color = "white", size = 4)
breaks <- quantile(data %>% pull(!!sym(selected)))
names(breaks) <- c(scales::percent(breaks / 100))
} else {
fill_text <- geom_text(aes(label = paste0(scales::comma(round(!!sym(selected), -5)))), # rounds to nearest 100k
color = "white", size = 4)
breaks <- quantile(data %>% pull(!!sym(selected)))[2:]
names(breaks) <- c(scales::comma(breaks))
}
title <- dict_vars$national_dropdown_label[which(dict_vars$var_readable == selected)][1]
legend_title <- dict_vars$var_pretty[which(dict_vars$var_readable == selected)][1]
data %>%
ggplot(aes(x = 1, y = 1, # A tile map without x or y axis changes will fill out the tile for the state
fill = !!sym(selected))) + # Selected variable
geom_tile() + # Imports x and y values
fill_text +
labs(x = "", y = "",
title = title,
fill = legend_title) +
facet_geo(facets = ~ ABBR, grid = "us_state_with_DC_PR_grid2") +
theme(plot.background = element_rect(colour = "white"), # Removes all of the grid elements that we don't need
panel.grid = element_blank(),
panel.grid.major = element_blank(),
axis.text = element_blank(),
axis.ticks = element_blank(),
axis.line = element_blank(),
panel.spacing = unit(0L, "pt"),
legend.position = "bottom",
# legend.text = element_text(angle = 45, vjust = .5),
strip.text.x = element_text(size = 9L)) +
scale_fill_binned(high = "#132B43", low = "#56B1F7", breaks = breaks) # reverses the default gradient direction so that dark blue is associated with larger values
}
render_tile_map <- function(data, selected) {
# ### Unnecessary if selected is being passed as a string
# # but we may want to pass the variable itself at some point
# selected_varname <- deparse(substitute(!!sym(selected))) %>% gsub("^[^\\$]*\\$", "", .)
# ### Parsing the regex
# # ^ anchor for beginning of string
# # [^\\$]* matches everything excluding "$" char
# # \\$ terminates match at "$" char
# # example: deparse(substitute(national_demographic_readable$GEOID)) %>% gsub("^[^\\$]*\\$", "", .)
# # outputs: "GEOID"
# Perform the important transformations to variables based on the type of number
if(grepl("pct", selected)) {
fill_text <- geom_text(aes(label = paste0(round(!!sym(selected), 1), '%')),
color = "white", size = 4)
breaks <- quantile(data %>% pull(!!sym(selected)))
names(breaks) <- c(scales::percent(breaks / 100))
} else {
fill_text <- geom_text(aes(label = paste0(scales::comma(round(!!sym(selected), -5)))), # rounds to nearest 100k
color = "white", size = 4)
breaks <- quantile(data %>% pull(!!sym(selected)))[2:]
names(breaks) <- c(scales::comma(breaks))
}
title <- dict_vars$national_dropdown_label[which(dict_vars$var_readable == selected)][1]
legend_title <- dict_vars$var_pretty[which(dict_vars$var_readable == selected)][1]
data %>%
ggplot(aes(x = 1, y = 1, # A tile map without x or y axis changes will fill out the tile for the state
fill = !!sym(selected))) + # Selected variable
geom_tile() + # Imports x and y values
fill_text +
labs(x = "", y = "",
title = title,
fill = legend_title) +
facet_geo(facets = ~ ABBR, grid = "us_state_with_DC_PR_grid2") +
theme(plot.background = element_rect(colour = "white"), # Removes all of the grid elements that we don't need
panel.grid = element_blank(),
panel.grid.major = element_blank(),
axis.text = element_blank(),
axis.ticks = element_blank(),
axis.line = element_blank(),
panel.spacing = unit(0L, "pt"),
legend.position = "bottom",
# legend.text = element_text(angle = 45, vjust = .5),
strip.text.x = element_text(size = 9L)) +
scale_fill_binned(high = "#132B43", low = "#56B1F7", breaks = breaks) # reverses the default gradient direction so that dark blue is associated with larger values
}
render_tile_map <- function(data, selected) {
# ### Unnecessary if selected is being passed as a string
# # but we may want to pass the variable itself at some point
# selected_varname <- deparse(substitute(!!sym(selected))) %>% gsub("^[^\\$]*\\$", "", .)
# ### Parsing the regex
# # ^ anchor for beginning of string
# # [^\\$]* matches everything excluding "$" char
# # \\$ terminates match at "$" char
# # example: deparse(substitute(national_demographic_readable$GEOID)) %>% gsub("^[^\\$]*\\$", "", .)
# # outputs: "GEOID"
# Perform the important transformations to variables based on the type of number
if(grepl("pct", selected)) {
fill_text <- geom_text(aes(label = paste0(round(!!sym(selected), 1), '%')),
color = "white", size = 4)
breaks <- quantile(data %>% pull(!!sym(selected)))
names(breaks) <- c(scales::percent(breaks / 100))
} else {
fill_text <- geom_text(aes(label = paste0(scales::comma(round(!!sym(selected), -5)))), # rounds to nearest 100k
color = "white", size = 4)
breaks <- quantile(data %>% pull(!!sym(selected)))[2:]
names(breaks) <- c(scales::comma(breaks))
}
title <- dict_vars$national_dropdown_label[which(dict_vars$var_readable == selected)][1]
legend_title <- dict_vars$var_pretty[which(dict_vars$var_readable == selected)][1]
data %>%
ggplot(aes(x = 1, y = 1, # A tile map without x or y axis changes will fill out the tile for the state
fill = !!sym(selected))) + # Selected variable
geom_tile() + # Imports x and y values
fill_text +
labs(x = "", y = "",
title = title,
fill = legend_title) +
facet_geo(facets = ~ ABBR, grid = "us_state_with_DC_PR_grid2") +
theme(plot.background = element_rect(colour = "white"), # Removes all of the grid elements that we don't need
panel.grid = element_blank(),
panel.grid.major = element_blank(),
axis.text = element_blank(),
axis.ticks = element_blank(),
axis.line = element_blank(),
panel.spacing = unit(0L, "pt"),
legend.position = "bottom",
legend.text = element_text(angle = 45, vjust = .5),
strip.text.x = element_text(size = 9L)) +
scale_fill_binned(high = "#132B43", low = "#56B1F7", breaks = breaks) # reverses the default gradient direction so that dark blue is associated with larger values
}
render_tile_map <- function(data, selected) {
# ### Unnecessary if selected is being passed as a string
# # but we may want to pass the variable itself at some point
# selected_varname <- deparse(substitute(!!sym(selected))) %>% gsub("^[^\\$]*\\$", "", .)
# ### Parsing the regex
# # ^ anchor for beginning of string
# # [^\\$]* matches everything excluding "$" char
# # \\$ terminates match at "$" char
# # example: deparse(substitute(national_demographic_readable$GEOID)) %>% gsub("^[^\\$]*\\$", "", .)
# # outputs: "GEOID"
# Perform the important transformations to variables based on the type of number
if(grepl("pct", selected)) {
fill_text <- geom_text(aes(label = paste0(round(!!sym(selected), 1), '%')),
color = "white", size = 4)
breaks <- quantile(data %>% pull(!!sym(selected)))[2:5]
names(breaks) <- c(scales::percent(breaks / 100))
} else {
fill_text <- geom_text(aes(label = paste0(scales::comma(round(!!sym(selected), -5)))), # rounds to nearest 100k
color = "white", size = 4)
breaks <- quantile(data %>% pull(!!sym(selected)))[2:5]
names(breaks) <- c(scales::comma(breaks))
}
title <- dict_vars$national_dropdown_label[which(dict_vars$var_readable == selected)][1]
legend_title <- dict_vars$var_pretty[which(dict_vars$var_readable == selected)][1]
data %>%
ggplot(aes(x = 1, y = 1, # A tile map without x or y axis changes will fill out the tile for the state
fill = !!sym(selected))) + # Selected variable
geom_tile() + # Imports x and y values
fill_text +
labs(x = "", y = "",
title = title,
fill = legend_title) +
facet_geo(facets = ~ ABBR, grid = "us_state_with_DC_PR_grid2") +
theme(plot.background = element_rect(colour = "white"), # Removes all of the grid elements that we don't need
panel.grid = element_blank(),
panel.grid.major = element_blank(),
axis.text = element_blank(),
axis.ticks = element_blank(),
axis.line = element_blank(),
panel.spacing = unit(0L, "pt"),
legend.position = "bottom",
legend.text = element_text(angle = 45, vjust = .5),
strip.text.x = element_text(size = 9L)) +
scale_fill_binned(high = "#132B43", low = "#56B1F7", breaks = breaks) # reverses the default gradient direction so that dark blue is associated with larger values
}
render_tile_map <- function(data, selected) {
# ### Unnecessary if selected is being passed as a string
# # but we may want to pass the variable itself at some point
# selected_varname <- deparse(substitute(!!sym(selected))) %>% gsub("^[^\\$]*\\$", "", .)
# ### Parsing the regex
# # ^ anchor for beginning of string
# # [^\\$]* matches everything excluding "$" char
# # \\$ terminates match at "$" char
# # example: deparse(substitute(national_demographic_readable$GEOID)) %>% gsub("^[^\\$]*\\$", "", .)
# # outputs: "GEOID"
# Perform the important transformations to variables based on the type of number
if(grepl("pct", selected)) {
fill_text <- geom_text(aes(label = paste0(round(!!sym(selected), 1), '%')),
color = "white", size = 4)
breaks <- quantile(data %>% pull(!!sym(selected)))[2:5]
names(breaks) <- c(scales::percent(breaks / 100))
} else {
fill_text <- geom_text(aes(label = paste0(scales::comma(round(!!sym(selected), -5)))), # rounds to nearest 100k
color = "white", size = 4)
breaks <- quantile(data %>% pull(!!sym(selected)))[2:5]
names(breaks) <- c(scales::comma(breaks))
}
title <- dict_vars$national_dropdown_label[which(dict_vars$var_readable == selected)][1]
legend_title <- dict_vars$var_pretty[which(dict_vars$var_readable == selected)][1]
data %>%
ggplot(aes(x = 1, y = 1, # A tile map without x or y axis changes will fill out the tile for the state
fill = !!sym(selected))) + # Selected variable
geom_tile() + # Imports x and y values
fill_text +
labs(x = "", y = "",
title = title,
fill = legend_title) +
facet_geo(facets = ~ ABBR, grid = "us_state_with_DC_PR_grid2") +
theme(plot.background = element_rect(colour = "white"), # Removes all of the grid elements that we don't need
panel.grid = element_blank(),
panel.grid.major = element_blank(),
axis.text = element_blank(),
axis.ticks = element_blank(),
axis.line = element_blank(),
panel.spacing = unit(0L, "pt"),
legend.position = "bottom",
# legend.text = element_text(angle = 45, vjust = .5),
strip.text.x = element_text(size = 9L)) +
scale_fill_binned(high = "#132B43", low = "#56B1F7", breaks = breaks) # reverses the default gradient direction so that dark blue is associated with larger values
}
render_tile_map(demographics, "pwd_pct")
render_tile_map <- function(data, selected) {
# ### Unnecessary if selected is being passed as a string
# # but we may want to pass the variable itself at some point
# selected_varname <- deparse(substitute(!!sym(selected))) %>% gsub("^[^\\$]*\\$", "", .)
# ### Parsing the regex
# # ^ anchor for beginning of string
# # [^\\$]* matches everything excluding "$" char
# # \\$ terminates match at "$" char
# # example: deparse(substitute(national_demographic_readable$GEOID)) %>% gsub("^[^\\$]*\\$", "", .)
# # outputs: "GEOID"
# Perform the important transformations to variables based on the type of number
if(grepl("pct", selected)) {
fill_text <- geom_text(aes(label = paste0(round(!!sym(selected), 1), '%')),
color = "white", size = 4)
breaks <- quantile(data %>% pull(!!sym(selected)))[2:5]
names(breaks) <- c(scales::percent(breaks / 100))
} else {
fill_text <- geom_text(aes(label = paste0(scales::comma(round(!!sym(selected), -5)))), # rounds to nearest 100k
color = "white", size = 4)
breaks <- quantile(data %>% pull(!!sym(selected)))[2:5]
names(breaks) <- c(scales::comma(breaks))
}
title <- dict_vars$national_dropdown_label[which(dict_vars$var_readable == selected)][1]
legend_title <- dict_vars$var_pretty[which(dict_vars$var_readable == selected)][1]
data %>%
ggplot(aes(x = 1, y = 1, # A tile map without x or y axis changes will fill out the tile for the state
fill = !!sym(selected))) + # Selected variable
geom_tile() + # Imports x and y values
fill_text +
labs(x = "", y = "",
title = title,
fill = legend_title) +
facet_geo(facets = ~ ABBR, grid = "us_state_with_DC_PR_grid2") +
theme(plot.background = element_rect(colour = "white"), # Removes all of the grid elements that we don't need
panel.grid = element_blank(),
panel.grid.major = element_blank(),
axis.text = element_blank(),
axis.ticks = element_blank(),
axis.line = element_blank(),
panel.spacing = unit(0L, "pt"),
legend.position = "bottom",
legend.text = element_text(angle = 90, vjust = .5),
strip.text.x = element_text(size = 9L)) +
scale_fill_binned(high = "#132B43", low = "#56B1F7", breaks = breaks) # reverses the default gradient direction so that dark blue is associated with larger values
}
render_tile_map(demographics, "pwd_pct")
?scale_fill_binned
scale_fill_binned("YlOrBr")
library(tidyverse)
scale_fill_binned("YlOrBr")
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(tidycensus)
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(tidycensus)
library(here)
# pull functions and variable tables
source(here("Scripts", "funs.R"))
source(here("Scripts", "vars.R"))
scale_fill
?scale_fill_continuous
colorRampPalette("YlOrBr")
scales::colour_ramp("YlOrBr")
?scales::colour_ramp
?scale_fill_manual
?knitr::kable

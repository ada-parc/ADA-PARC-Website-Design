}
render_geo_interactive_map <- function(data, category, variable,
palette_selected = "YlOrBr") {
if(!is.data.frame(data) & !is_tibble(data)) {
stop("data must be a dataframe or tibble object")
}
if(!is.character(category)) {
stop("selected category must be a character string")
}
if(!is.character(variable)) {
stop("selected variable must be a character string")
}
legend_title <- paste0(dict_vars$var_pretty[which(dict_vars$var_readable == variable)][1])
print(isCompVar(category, variable))
if(!isCompVar(category, variable)){
tmap_mode("view")
states_sf <- getUrbnGeo(data, variable)
makeTmapObject(states_sf, variable, legend_title, palette_selected) +
tm_view(set.view = 3.5,
leaflet.options = list(zoomSnap = 0.5,
zoomDelta = 0.5),
view.legend.position = c("left", "bottom"))
} else {
# tmap_mode("plot")
print("else branch")
comp_var <- getCompVar(category, variable)
legend_title_comp <- paste0(dict_vars$var_pretty[which(dict_vars$var_readable == comp_var)][1])
states_sf <- getUrbnGeo(data, variable) %>%
mutate(facet_ref = 1)
# p1 <- makeTmapObject(states_sf, variable, legend_title, palette_selected)
# print("p1 made")
states_sf_comp <- getUrbnGeo(data, comp_var) %>%
mutate(facet_ref = 2)
# p2 <- makeTmapObject(states_sf_comp, comp_var, legend_title_comp, palette_selected)
# print("p2 made")
states_sf <- states_sf %>%
bind_rows(states_sf_comp) %>%
mutate(variable = coalesce(!!sym(variable), !!sym(comp_var))) %>%
select(ABBR, variable, geometry, hover_text, facet_ref = facet)
makeTmapObject(states_sf, selected = "variable", palette_selected = palette_selected, facet = T)
# tmap_arrange(p1, p2, ncol = 2)
# return(p1, p2)
}
}
makeTmapObject(states_sf, selected = "variable", palette_selected = "YlOrBr", facet = T)
makeTmapObject(states_sf, selected = "variable", palette_selected = "YlOrBr", facet = T)
makeTmapObject <- function(states_sf, selected, title = "", palette_selected, facet = F) {
tmap_object <- tm_shape(states_sf) +
tm_basemap(NULL) +
tm_shape(states_sf) +
tm_borders(col = "black", lwd = 0.3) +
tm_layout(legend.stack = "horizontal")
if(facet) {
tmap_object +
tm_polygons(
col = selected,
style = "quantile",
n = 4,
palette = palette_selected,
popup.vars = c("Selected variable: " = "hover_text"),
title = title,
legend.format = list(fun = function(x)
if(grepl("_pct$", selected)) {
paste0(round(x, 1), "%") }
else { scales::comma(x) } )
) +
tm_facets(by = tmap_object$facet_ref, as.layers = T)
} else {
tmap_object +
tm_polygons(
col = variable,
style = "quantile",
n = 4,
palette = palette_selected,
popup.vars = c("Selected variable: " = "hover_text"),
title = title,
legend.format = list(fun = function(x)
if(grepl("_pct$", selected)) {
paste0(round(x, 1), "%") }
else { scales::comma(x) } )
)
}
}
makeTmapObject(states_sf, selected = "variable", palette_selected = "YlOrBr", facet = T)
makeTmapObject <- function(states_sf, selected, title = "", palette_selected, facet = F) {
if(facet) {
tm_shape(states_sf) +
tm_basemap(NULL) +
tm_polygons(
col = selected,
style = "quantile",
n = 4,
palette = palette_selected,
popup.vars = c("Selected variable: " = "hover_text"),
title = title,
legend.format = list(fun = function(x)
if(grepl("_pct$", selected)) {
paste0(round(x, 1), "%") }
else { scales::comma(x) } )
) +
tm_shape(states_sf) +
tm_borders(col = "black", lwd = 0.3) +
tm_layout(legend.stack = "horizontal") +
tm_facets(by = tmap_object$facet_ref, as.layers = T)
} else {
tm_shape(states_sf) +
tm_basemap(NULL) +
tm_polygons(
col = selected,
style = "quantile",
n = 4,
palette = palette_selected,
popup.vars = c("Selected variable: " = "hover_text"),
title = title,
legend.format = list(fun = function(x)
if(grepl("_pct$", selected)) {
paste0(round(x, 1), "%") }
else { scales::comma(x) } )
) +
tm_shape(states_sf) +
tm_borders(col = "black", lwd = 0.3) +
tm_layout(legend.stack = "horizontal")
}
}
makeTmapObject(states_sf, selected = "variable", palette_selected = "YlOrBr", facet = T)
makeTmapObject <- function(states_sf, selected, title = "", palette_selected, facet = F) {
if(facet) {
tm_shape(states_sf) +
tm_basemap(NULL) +
tm_polygons(
col = selected,
style = "quantile",
n = 4,
palette = palette_selected,
popup.vars = c("Selected variable: " = "hover_text"),
title = title,
legend.format = list(fun = function(x)
if(grepl("_pct$", selected)) {
paste0(round(x, 1), "%") }
else { scales::comma(x) } )
) +
tm_shape(states_sf) +
tm_borders(col = "black", lwd = 0.3) +
tm_layout(legend.stack = "horizontal") +
tm_facets(by = facet_ref, as.layers = T)
} else {
tm_shape(states_sf) +
tm_basemap(NULL) +
tm_polygons(
col = selected,
style = "quantile",
n = 4,
palette = palette_selected,
popup.vars = c("Selected variable: " = "hover_text"),
title = title,
legend.format = list(fun = function(x)
if(grepl("_pct$", selected)) {
paste0(round(x, 1), "%") }
else { scales::comma(x) } )
) +
tm_shape(states_sf) +
tm_borders(col = "black", lwd = 0.3) +
tm_layout(legend.stack = "horizontal")
}
}
makeTmapObject(states_sf, selected = "variable", palette_selected = "YlOrBr", facet = T)
makeTmapObject <- function(states_sf, selected, title = "", palette_selected, facet = F) {
if(facet) {
tm_shape(states_sf) +
tm_basemap(NULL) +
tm_polygons(
col = selected,
style = "quantile",
n = 4,
palette = palette_selected,
popup.vars = c("Selected variable: " = "hover_text"),
title = title,
legend.format = list(fun = function(x)
if(grepl("_pct$", selected)) {
paste0(round(x, 1), "%") }
else { scales::comma(x) } )
) +
tm_shape(states_sf) +
tm_borders(col = "black", lwd = 0.3) +
tm_layout(legend.stack = "horizontal") +
tm_facets(by = "facet_ref", as.layers = T)
} else {
tm_shape(states_sf) +
tm_basemap(NULL) +
tm_polygons(
col = selected,
style = "quantile",
n = 4,
palette = palette_selected,
popup.vars = c("Selected variable: " = "hover_text"),
title = title,
legend.format = list(fun = function(x)
if(grepl("_pct$", selected)) {
paste0(round(x, 1), "%") }
else { scales::comma(x) } )
) +
tm_shape(states_sf) +
tm_borders(col = "black", lwd = 0.3) +
tm_layout(legend.stack = "horizontal")
}
}
makeTmapObject(states_sf, selected = "variable", palette_selected = "YlOrBr", facet = T)
states_sf
states_sf <- states_sf %>% select(ABBR, variable, facet_ref = facet, hover_text, geometry)
makeTmapObject(states_sf, selected = "variable", palette_selected = "YlOrBr", facet = T)
render_geo_interactive_map(community_participation, "is_community_participation", "pwd_19_64")
makeTmapObject <- function(states_sf, selected, title = "", palette_selected) {
tmap_object <- tm_shape(states_sf) +
tm_basemap(NULL) +
tm_polygons(
col = selected,
style = "quantile",
n = 4,
palette = palette_selected,
popup.vars = c("Selected variable: " = "hover_text"),
title = title,
legend.format = list(fun = function(x)
if(grepl("_pct$", selected)) {
paste0(round(x, 1), "%") }
else { scales::comma(x) } )
) +
tm_shape(states_sf) +
tm_borders(col = "black", lwd = 0.3) +
tm_layout(legend.stack = "horizontal")
}
render_geo_interactive_map <- function(data, category, variable,
palette_selected = "YlOrBr") {
if(!is.data.frame(data) & !is_tibble(data)) {
stop("data must be a dataframe or tibble object")
}
if(!is.character(category)) {
stop("selected category must be a character string")
}
if(!is.character(variable)) {
stop("selected variable must be a character string")
}
legend_title <- paste0(dict_vars$var_pretty[which(dict_vars$var_readable == variable)][1])
print(isCompVar(category, variable))
if(!isCompVar(category, variable)){
tmap_mode("view")
states_sf <- getUrbnGeo(data, variable)
makeTmapObject(states_sf, variable, legend_title, palette_selected) +
tm_view(set.view = 3.5,
leaflet.options = list(zoomSnap = 0.5,
zoomDelta = 0.5),
view.legend.position = c("left", "bottom"))
} else {
tmap_mode("view")
print("else branch")
comp_var <- getCompVar(category, variable)
legend_title_comp <- paste0(dict_vars$var_pretty[which(dict_vars$var_readable == comp_var)][1])
states_sf <- getUrbnGeo(data, variable) %>%
mutate(facet = 1)
p1 <- makeTmapObject(states_sf, variable, legend_title, palette_selected)
print("p1 made")
states_sf_comp <- getUrbnGeo(data, comp_var) %>%
mutate(facet = 2)
p2 <- makeTmapObject(states_sf_comp, comp_var, legend_title_comp, palette_selected)
print("p2 made")
tmap_arrange(p1, p2, ncol = 2)
}
}
render_geo_interactive_map(community_participation, "is_community_participation", "pwd_19_64")
library(remotes)
install_github("mtennekes/tmaptools")
library(remotes)
install_github("mtennekes/tmaptools")
library(remotes)
install_github("mtennekes/tmaptools")
### ----- Libraries -----
# Packages
library(tidyverse)
library(gridExtra)
library(tigris); library(sf)
# library(geofacet)
library(urbnmapr)
library(leaflet); library(leaflet.extras)
library(tmap); library(tmaptools)
library(htmltools)
library(shiny)
library(shinycssloaders)
# devtools::install_github("daattali/shinycssloaders", ref = "rmarkdown") # rmarkdown branch must be installed and cssloaders_in_header.html must exist
library(shinyWidgets); library(flexdashboard)
library(colourpicker); library(gghighlight)
library(knitr); library(kableExtra)
library(openxlsx); library(scales)
library(hrbrthemes); library(ggthemes)
library(extrafont); library(plotly)
library(mongolite); library(here)
options(scipen = 999999,
tigris_use_cache = TRUE)
knitr::opts_chunk$set(fig.cap = TRUE)
### ----- Database connections -----
# Set this to host_prod or host_dev
host_name = "host_dev"
### ----- Functions import -----
# Load API keys and database connection information
source(here("functions.R"), local = TRUE)
# Load variable dictionary for relating tables, variable codes,
# and readable values
dict_vars <- fun_pull_mongo_data(tables = "dict_vars",
host_name = host_name)
### ----- National Data import and clean -----
# This script takes the national_* objects and transforms them
# into the final datasets for mapping
source(here("national_import.R"), local = TRUE)
source("C:/Users/ethan/Desktop/ADA PARC/ADA-PARC-Website-Design/sandbox.R", echo=TRUE)
states_sf <- getUrbnGeo(demographics, "pop_total")
selected <- "pop_total"
legend_title <- paste0(dict_vars$var_pretty[which(dict_vars$var_readable == selected)][1])
palette_selected = "YlOrBr"
makeTmapObject(states_sf, selected, legend_title, palette_selected)
render_geo_interactive_map(demogaphics, "pop_total")
render_geo_interactive_map(demographics, "pop_total")
getUrbnGeo(demographics, "pop_total")
getUrbnGeo(demographics, "pop_total") -> states_sf
makeTmapObject(states_sf, "pop_total")
makeTmapObject(states_sf, "pop_total", "YlOrBr")
makeTmapObject(states_sf, "pop_total", palette_selected = "YlOrBr")
selected <- "pop_total"
tmap_object <- tm_shape(states_sf) +
tm_basemap(NULL) +
tm_polygons(
col = selected,
style = "quantile",
n = 4,
palette = palette_selected,
popup.vars = c("Selected variable: " = "hover_text"),
title = title,
legend.format = list(fun = function(x)
if(grepl("_pct$", selected)) {
paste0(round(x, 1), "%") }
else { scales::comma(x) } )
) +
tm_shape(states_sf) +
tm_borders(col = "black", lwd = 0.3) +
tm_layout(legend.stack = "horizontal") +
tm_view(set.view = 3.5,
leaflet.options = list(zoomSnap = 0.5,
zoomDelta = 0.5),
view.legend.position = c("left", "bottom"))
tmap_object
makeTmapObject <- function(states_sf, selected, title = "", palette_selected) {
tmap_object <- tm_shape(states_sf) +
tm_basemap(NULL) +
tm_polygons(
col = selected,
style = "quantile",
n = 4,
palette = palette_selected,
popup.vars = c("Selected variable: " = "hover_text"),
title = title,
legend.format = list(fun = function(x)
if(grepl("_pct$", selected)) {
paste0(round(x, 1), "%") }
else { scales::comma(x) } )
) +
# tm_shape(states_sf) +
tm_borders(col = "black", lwd = 0.3) +
tm_layout(legend.stack = "horizontal") +
tm_view(set.view = 3.5,
leaflet.options = list(zoomSnap = 0.5,
zoomDelta = 0.5),
view.legend.position = c("left", "bottom"))
}
makeTmapObject(states_sf, "pop_total", palette_selected = "YlOrBr")
makeTmapObject <- function(states_sf, selected, title = "", palette_selected) {
tmap_object <- tm_shape(states_sf) +
tm_basemap(NULL) +
tm_polygons(
col = selected,
style = "quantile",
n = 4,
palette = palette_selected,
popup.vars = c("Selected variable: " = "hover_text"),
title = title,
legend.format = list(fun = function(x)
if(grepl("_pct$", selected)) {
paste0(round(x, 1), "%") }
else { scales::comma(x) } )
) +
# tm_shape(states_sf) +
tm_borders(col = "black", lwd = 0.3) +
tm_layout(legend.stack = "horizontal") +
tm_view(set.view = 3.5,
leaflet.options = list(zoomSnap = 0.5,
zoomDelta = 0.5),
view.legend.position = c("left", "bottom"))
tmap_object
}
makeTmapObject(states_sf, "pop_total", palette_selected = "YlOrBr")
# render_geo_interactive_map(community_participation, "pwod_19_64_insured_pct")
render_geo_interactive_map(demographics, "pop_total")
render_geo_interactive_map(community_participation, "pwod_19_64_insured_pct")
?grid.arrange
rlang::last_error()
?req
?get_urbn_map
devtools::install_github("UrbanInstitute/urbnmapr")
source("C:/Users/ethan/Desktop/ADA PARC/ADA-PARC-Website-Design/functions.R", echo=TRUE)
### ----- Libraries -----
# Packages
library(tidyverse)
library(gridExtra)
library(tigris); library(sf)
# library(geofacet)
library(urbnmapr)
library(leaflet); library(leaflet.extras)
library(tmap); library(tmaptools)
library(htmltools)
library(shiny)
library(shinycssloaders)
# devtools::install_github("daattali/shinycssloaders", ref = "rmarkdown") # rmarkdown branch must be installed and cssloaders_in_header.html must exist
library(shinyWidgets); library(flexdashboard)
library(colourpicker); library(gghighlight)
library(knitr); library(kableExtra)
library(openxlsx); library(scales)
library(hrbrthemes); library(ggthemes)
library(extrafont); library(plotly)
library(mongolite); library(here)
options(scipen = 999999,
tigris_use_cache = TRUE)
knitr::opts_chunk$set(fig.cap = TRUE)
### ----- Database connections -----
# Set this to host_prod or host_dev
host_name = "host_dev"
### ----- Functions import -----
# Load API keys and database connection information
source(here("functions.R"), local = TRUE)
# Load variable dictionary for relating tables, variable codes,
# and readable values
dict_vars <- fun_pull_mongo_data(tables = "dict_vars",
host_name = host_name)
### ----- National Data import and clean -----
# This script takes the national_* objects and transforms them
# into the final datasets for mapping
source(here("national_import.R"), local = TRUE)
dict_vars %>% filter(is_community_participation, !is.na(national_dropdown_label))
render_national_map(community_participation, "is_community_participaton","pwod_19_64_uninsured_pct")
render_national_map(community_participation, "is_community_participation","pwod_19_64_uninsured_pct")
render_national_map(demographics, "is_demographics","pop_total")
render_national_map("is_demographics", "pop_total")
# rename, since this isn't exclusively for interactive maps
# probably renderNationalMap()
render_national_map <- function(category, selected,
palette_selected = "YlOrBr") {
# if(!is.data.frame(data) & !is_tibble(data)) {
#   stop("data must be a dataframe or tibble object")
# }
# print(class(data))
# print(class(eval(sym(str_remove(category, "^is_")))))
if(!is.character(category)) {
stop("category must be a character string")
}
if(!is.character(selected)) {
stop("selected must be a character string")
}
data <- eval(sym(str_remove(category, "^is_")))
no_classes <- 4
# p1
legend_title <- paste0(dict_vars$var_pretty[which(dict_vars$var_readable == selected)][1])
quartiles <- quantile(data %>% pull(!!sym(selected)),
probs = seq(0, 1, length.out = no_classes + 1),
na.rm = TRUE)
labels <- set_quartile_labels(quartiles, 4, selected)
if(!isCompVar(category, selected)){
# p1
# states_sf <- getUrbnGeo(data, selected, interactive = T)
# makeTmapObject(states_sf, selected, legend_title, palette_selected)
states_sf <- getUrbnGeo(data, selected, quartiles, labels, interactive = F)
makeGgplotObject(states_sf, legend_title, palette_selected)
} else {
# p1
states_sf <- getUrbnGeo(data, selected, quartiles, labels, interactive = F)
p1 <- makeGgplotObject(states_sf, legend_title, palette_selected)
# p2
comp_var <- getCompVar(category, selected)
legend_title_comp <- paste0(dict_vars$var_pretty[which(dict_vars$var_readable == comp_var)][1])
quartiles <- quantile(data %>% pull(!!sym(comp_var)),
probs = seq(0, 1, length.out = no_classes + 1),
na.rm = TRUE)
labels <- set_quartile_labels(quartiles, 4, comp_var)
states_sf <- getUrbnGeo(data, comp_var, quartiles, labels, interactive = F)
p2 <- makeGgplotObject(states_sf, legend_title_comp, palette_selected)
grid.arrange(p1, p2, ncol = 2)
}
}
render_national_map("is_demographics", "pop_total")
render_national_map("is_community_participation","pwod_19_64_uninsured_pct")
?req
install.packages("reactlog")
reactlog()
reactlog::reactlog_show()
shiny::reactlogShow()
shiny::reactlogShow()
eval("national")
nat <- "national"
sym(nat)
eval(sym(nat))
eval(nat)
shiny::reactlogShow()
dict_vars %>%
filter(var_readable == "pwd_19_64", "is_community_living") %>%
pull(display_type)
dict_vars %>%
filter(var_readable == "pwd_19_64", is_community_living) %>%
pull(display_type)

---
title: "ADA-PARC v2"
output:
  flexdashboard::flex_dashboard:
    orientation: rows
    vertical_layout: scroll
    theme: cosmo
    includes:
      in_header: www/cssloaders.html
    css: www/styles.css
runtime: shiny
resource_files:
- www/participant_logos.png
- scripts/functions.R
- data/dict_vars.csv
- data/final/city_place_full.Rds
- data/final/dict_location_crosswalk.Rds
- data/final/tract_data.Rds
- data/final/tracts_sf.Rds
- data/final/national_data.Rds
- data/final/tracts_data.Rds
editor_options: 
  markdown: 
    wrap: 72
---

```{r setup, include=FALSE}

### ----- Packages ----- 

library(tidyverse)
library(patchwork)
library(sf)
library(leaflet)
library(leaflet.extras)
library(htmltools)
library(shiny)
library(shinycssloaders)
library(shinyWidgets)
library(flexdashboard)
library(colourpicker)
library(scales)
library(tableHTML)
library(hrbrthemes)
library(ggthemes)
library(extrafont)
library(sf)
library(tigris)
library(RColorBrewer)
library(cowplot)
library(readxl)
library(kableExtra)


options(scipen = 999999,
        tigris_use_cache = TRUE,
        shiny.reactlog = TRUE)
knitr::opts_chunk$set(fig.cap = TRUE)

#################################
#################################
# Load data:
#################################
#################################
city_place_full <- readRDS(here::here("data", "final", "city_place_full.Rds")) 

dict_location_crosswalk <- readRDS(here::here("data", "final", "dict_location_crosswalk.Rds")) 
tracts_data <- readRDS(here::here("data", "final", "tracts_data.Rds")) 

national_data <- readRDS(here::here("data", "final", "national_data.Rds")) 

tracts_sf <- readRDS(here::here("data", "final", "tracts_sf.Rds"))


# Read in variable dictionary manually
dict_vars <- read_csv(here::here("data", "dict_vars.csv"))

east_coast_states_to_relocate <- c("RI", "DE", "DC", "MD")

us_states <- states(cb = TRUE, resolution = "20m") %>%
  shift_geometry() %>%
  sf::st_cast("MULTIPOLYGON") %>% 
  select(GEOID, ABBR = STUSPS, NAME, geometry)

us_states <- us_states %>% 
  left_join(
    us_states %>%
      sf::st_drop_geometry() %>%
      bind_cols(
        us_states %>%
          sf::st_centroid() %>%
          sf::st_coordinates() %>% 
          as_tibble()
      )
  ) %>% 
  mutate(
    x_lab = case_when(
      ABBR %in% east_coast_states_to_relocate ~ 2300000,
      ABBR == "FL" ~ X + 80000,
      ABBR == "LA" ~ X - 60000,
      .default = X
    ),
    y_lab = case_when(
      ABBR == "DC" ~ Y - 180000,
      ABBR == "DE" ~ Y + 100000,
      ABBR == "NH" ~ Y - 40000,
      ABBR == "VT" ~ Y + 40000,
      ABBR == "MD" ~ Y - 40000,
      ABBR == "LA" ~ Y + 40000,
      .default = Y
    )
  ) %>% 
  left_join(national_data)

### ----- Functions import -----

source(here::here("scripts", "functions.R"), local = TRUE)

```

# Home

## Sidebar {.sidebar}

<br>

#### How to Navigate<br>this Website

<br> Use the **National Data** tab to examine the status of people with
disabilities at the national and state level.

Use the **City Data** tab to investigate people with disabilities
statistics at the municipal level.

Use the **Community Reports** tab to view our state by state report cards.

Use the **About** tab to learn more about the ADA-PARC project. 

Use the **Settings** tab to set color palettes for the visualizations in
this dashboard.

<br>

**Questions?** <br> [Contact Joy Hammel (email)](mailto:hammel@uic.edu)
<br> Director of Graduate Studies <br> UIC College of Applied Health
Sciences

Application authors: <br> Ethan Jantz, Sean Connelly, Jane Huber, and
Randy D. Col√≥n <br> [UIC Voorhees
Center](https://voorheescenter.uic.edu/)

::: {role="main"}
## Row

### 

<br>

Welcome to the ADA-PARC website. The ADA-PARC is a collaborative
research project of ten Americans with Disabilities Act (ADA) Regional
Centers.

**What is the ADA?**
<br>

Established in 1990, the Americans with Disabilities Act (ADA), is a civil
rights law which protects people with disabilities from discrimination.

<br>

**Since the ADA**, insert preferred info here

<br>

<div style="text-align: center; margin-top: 20px; margin-bottom: 20px;">
  <img src="./www/002_Percent of People with Disabilities.png" alt="Percent of People with Disabilities" width="50%">
</div>

<br>

**Did You Know?**
<br>
Insert preferred info here

<br>
:::

::: {role="main"}
# National Data

::: {role="region" aria-labelledby="sidebar"}
## Sidebar {.sidebar}

<br>

To explore the data first select a category and then a topic. You can
navigate the boxes below using the mouse or keyboard. For keyboard
users, once the box is highlighted you can press backspace and begin
typing the selection into the box.

```{r national-sidebar, context="server", message=FALSE, warning=FALSE, fig.alt = "A sidebar containing two drop down menus. One selects a category, and the other selects a topic within that category. These other elements of this page will change based on the selected category and topic."}


### ----- Category selector ------

# National category selection widget
national_category_choices <- c(
  "Demographics" = "is_demographics", 
  "Community Participation" = "is_community_participation", 
  "Community Living" = "is_community_living", 
  "Work/Economic" = "is_work_economic"
)

# Select the data frame to use
selectInput(inputId = "national_category_selector", 
            label = "Select a category", 
            choices = names(national_category_choices),
            selected = "is_demographics",
            multiple = FALSE)

# Selected category for function inputs
# Output looks like "is_demographics"
national_category_selected <- reactive({ 
  
  getElement(national_category_choices, input$national_category_selector)
  
})

### ----- Variable selector  ------


# National variable selection choices, based on category
national_variable_choices <- reactive({
  
  tibble::deframe(
    dict_vars %>%
      filter(!!sym(national_category_selected()) == TRUE,
             !is.na(national_dropdown_label)) %>%
      select(national_dropdown_label, var_readable)
  )
  
})

# National variable selection widget, default options
selectInput(inputId = "national_variable_selector",
            label = "Select a topic",
            choices = tibble::deframe(c("Population", "pop_total")),
            selected = "pop_total",
            multiple = FALSE)

# Update variable selections when category changes
observeEvent(input$national_category_selector, {
  
  choices <- names(national_variable_choices())
  
  updateSelectInput(session, "national_variable_selector",
                    choices = choices, 
                    selected = choices[1])
  
})

# Try debouncing, didn't fire early enough
# national_variable_selector_db <- debounce(reactive({input$national_variable_selector}), 2000)

# Selected variable for function inputs
# Output looks like "pop_total"
national_variable_selected <- reactive({ 
  
  # req(national_variable_selector_db())
  req(national_category_selected())
  
  getElement(national_variable_choices(), input$national_variable_selector)
  
})

### For debugging
# renderText({ is.null(national_category_selected()) })
# renderText({ is.null(national_variable_selected()) })
# renderText({ national_category_selected() })
# renderText({ national_variable_selected() })
# renderText({ national_variable_choices() })


### ----- Summary text  ------


# Summary text
output$national_map_summary <- renderUI({
  
  national_variable_selected <- national_variable_selected()
  
  hud_data <- c("pwd_housing_choice_voucher_pct", "pwd_pubhousing_pct")
  
  # This text here is a hack--long term, source information should be authored in our pipeline and simply read here.
  
  if(national_variable_selected %in% hud_data) {
      source_text <- "2022 United States Department of Housing and Urban Development"

  } else {
      source_text <- "2018-2022 American Community Survey five-year estimates"

  }
  
  full_text <- paste0(" Detailed information is available to the right in the interactive map (top) and table (bottom).<br><br>Source: ", source_text)
  
  HTML(
    paste0(
      altText(national_data, 
              national_variable_selected), full_text)
  )
  
})

withSpinner(uiOutput("national_map_summary"))

```
:::

## Row {data-height="50"}

::: {role="region" aria-labelledby="section-national-title"}
```{r national-map-title, fig.alt = "Map title the selected topic."}

output$national_map_title <- renderUI({

  title <- dict_vars %>% 
    filter(var_readable == sym(national_variable_selected())) %>% 
    head(1) %>% 
    pull(national_dropdown_label) %>%
    sub(".*:", "", .) %>% 
    trimws()
  
  h4(title)

})

withSpinner(uiOutput("national_map_title"))


```
:::

## Row

::: {role="region" aria-labelledby="section-state-by-state-map-of-selected-topic"}
### 

```{r national-map, out.width = "100%", fig.align = "center", fig.cap= "A map of the United States, with each state shaded according to the quartiles described in the summary.", fig.alt= "A map of the United States, with each state shaded according to the quartiles described in the summary."}

output$national_ggmap <- renderPlot({
  
  render_national_map(national_variable_selected(), 
                      access_map_palette_selected())
  
})

output$national_map <- renderUI({
  
  withSpinner(plotOutput(outputId = "national_ggmap"))
  
})

uiOutput("national_map")



# For debugging
# Static version of comparison map
# render_national_map(
#   "is_demographics",
#   "pwd_pct",
#   "YlOrBr"
# )

```
:::

## Row

::: {role="region" aria-labelledby="section-table-of-selected-topic"}
###  {.table-wrapper}

```{r national-table, fig.alt = "Data table including state-level data for variables relevant to the selected topic."}

# Get variable group based on selected variable
national_vars_in_topic <- reactive({
  
  dict_vars %>% 
    filter((!!sym(national_category_selected())) == TRUE,
           var_topic ==
             (dict_vars %>% 
                filter((!!sym(national_category_selected())) == TRUE &
                       var_readable == national_variable_selected()) %>% 
                pull(var_topic)),
           display == T) %>% 
    select(var_pretty, var_readable)
  
  # # Static check
  # national_vars_in_topic_static <- dict_vars %>%
  #   filter(is_demographics == TRUE,
  #          var_topic ==
  #          (dict_vars %>%
  #             filter(is_demographics == TRUE,
  #                    var_readable == "pwd_18_64_pct") %>%
  #             pull(var_topic))) %>%
  #   select(var_pretty, var_readable)
  
})

# Caption
cap_choices <- c("Demographics" = "is_demographics", 
                 "Community Participation" = "is_community_participation", 
                 "Community Living" = "is_community_living", 
                 "Work/Economic" = "is_work_economic")

table_caption <- reactive({
  
  paste(names(cap_choices[cap_choices == national_category_selected()]), "Table")
  
})

# Reorganize dataframe, switch to pretty names
national_data_table_friendly <- reactive({
  
  national_data %>%
    arrange(GEOID) %>% 
    mutate("State" = paste0(NAME
    )
    ) %>% 
    select(any_of(c("State",
                    national_vars_in_topic() %>% 
                      pull(var_readable)))) %>% 
    mutate(across(ends_with("_pct"),
                  ~scales::percent(.x,
                                   accuracy = 0.1,
                                   scale = 1))) %>%
    rename(!!any_of(national_vars_in_topic() %>% 
                      deframe())) %>%
    select(State, starts_with("Population"), starts_with("Percent"), everything())
  
  # # Static check
  # table_friendly <- demographics %>%
  #   mutate("State" = paste0(NAME
  #                           # " (", ABBR, ")"
  #                           )) %>%
  #   select(any_of(c("State",
  #                   national_vars_in_topic_static %>%
  #                     pull(var_readable)))) %>%
  #   mutate(across(-State & -ends_with("_pct"),
  #                 ~scales::comma(.x))) %>%
  #   mutate(across(ends_with("_pct"),
  #                 ~scales::percent(.x,
  #                                  accuracy = 0.1,
  #                                  scale = 1))) %>%
  #   rename(!!any_of(national_vars_in_topic_static %>%
  #                     deframe()))
  
})

# UI Output
output$national_table <- renderUI({ 
  
  # This is incredibly hacky
  # But I can't find a better way to make these
  # tables accessible at this point in time
  HTML(
    tableHTML(national_data_table_friendly() %>% 
                mutate(State = paste0(State, "a")), rownames = F, class = "table_national") %>% 
      # Essentially, this respecifies the first column as a column of table headers. See link below
      # https://www.w3.org/WAI/tutorials/tables/two-headers/
      replace_html('<td id="tableHTML_column_1">', '<th scope="row" id="tableHTML_column_1">', replace_all = T) %>% 
      replace_html('[a-z]</td>', '</th>', replace_all = T)
  )
  
  # Static check
  # HTML(
  #   tableHTML(table_friendly %>%
  #               mutate(State = paste0(State, "a")),
  #             rownames = F, class = "table_national") %>%
  #     # Essentially, this respecifies the first column as a column of table headers. See link below
  #     # https://www.w3.org/WAI/tutorials/tables/two-headers/
  #     replace_html('<td id="tableHTML_column_1">', '<th scope="row" id="tableHTML_column_1">', replace_all = T) %>%
  #     replace_html('[a-z]</td>', '</th>', replace_all = T)
  # )
  
})

withSpinner(uiOutput("national_table"))

```
:::
:::

::: {role="main"}
# City Data

## Sidebar {.sidebar}

To explore the data select a city below. You can navigate the selection
boxes using the mouse or keyboard. For keyboard users, once the box is
highlighted you can press backspace and begin typing the selection into
the box. A state must be selected first.

```{r city-sidebar}

# Define inputs, restrict to cities in database

state_choices <- tibble(NAME = state.name, ABB =  state.abb) %>%
  add_row(NAME = c("District of Columbia", "Puerto Rico"),
          ABB = c("DC", "PR")) %>%
  deframe()

selectInput(inputId = "state_selector",
            label = "Select a state",
            choices = state_choices,
            selected = state_choices[13])

state_selected <- reactive({
  state_choices[which(state_choices == input$state_selector)]
})

# City choices, based on state, remove CDPs for now
city_choices <- reactive({
  
  tibble::deframe(
    dict_location_crosswalk %>%
      filter(state == state_selected(),
             !str_detect(place_NAME, " CDP")) %>%
      select(place_NAME, state, place_GEOID) %>%
      distinct(place_NAME, place_GEOID)
  ) %>%
    sort()
  
})

selectInput(inputId = "city_selector", 
            label = "Select a city", 
            choices =   tibble::deframe(
    dict_location_crosswalk %>%
      filter(state == "IL") %>%
      select(place_NAME, state, place_GEOID) %>%
      distinct(place_NAME, place_GEOID)
  ),
            selected = "1714000")

# Update variable selections when category changes
observeEvent(input$state_selector, {
  
  choices <- names(city_choices())
  
  updateSelectInput(session, "city_selector",
                    choices = choices, 
                    selected = choices[2])
  
})

city_selected <- reactive({ 
  
  # req(national_variable_selector_db())
  req(state_selected())
  
  getElement(city_choices(), input$city_selector)
  
})

### ----- Pull Census Place data for selected city -----

# Place for selected city
city_place <- reactive({

  city_place_geoids <- city_place_full%>% 
    filter(GEOID == city_selected())
  
    city_place_full %>% 
    filter(GEOID == city_selected())
  
})

### ----- Pull Census Tract data for selected city -----

# Spatial
city_tract_sf <- reactive({
  
  # Restrict tract call to selected city
  temp_city <- dict_location_crosswalk %>% 
    filter(place_GEOID %in% city_selected()) %>% 
    pull(tract_GEOID)
  
  temp_sf <- tracts_sf %>%
    filter(tract_GEOID %in% temp_city)
  
  return(temp_sf)
  
})

# Tabular
city_tract <- reactive ({
  
  temp_city <- dict_location_crosswalk %>%
    filter(place_GEOID %in% city_selected()) %>%
    pull(tract_GEOID)
  
  temp <- tracts_data %>%
    filter(GEOID %in% temp_city) 

  # # Connect and pull
  # temp_mongo_conn <- fun_mongo_connect(host_name,
  #                                      collection_name = "acs_tract_S1810",
  #                                      database_name = "ADA-PARC")
  # temp <- temp_mongo_conn$find(
  #   query = sprintf('{ "GEOID" : { "$in" : [  "%s" ] } }' ,
  #                   str_c(city_tract_sf()$t_GEOID, collapse = '", "')))
  return(temp)
  
})
```

## Row {data-height="50"}

::: {role="region" aria-labelledby="section-national-title"}
```{r city-map-title, fig.alt = "City Map Title"}

output$city_map_title <- renderUI({

  title <- city_place() %>% 
      mutate(NAME = str_replace_all(NAME, pattern = " (city|village|municipality|town), ", replacement = ", ")) %>% 
      pull(NAME)
  
  h4(title)
  
    # # Static check
    # altTitle(demographics,
    #         national_variable_selector_static)

  
})

withSpinner(uiOutput("city_map_title"))

```
:::

## Row

::: {role="region" aria-labelledby="section-people-with-disabilities-map"}
### 

```{r city-pwd-map, fig.alt="Map of people with disabilities by census tract in the selected city", context="server"}

 # Addison Village: 1700243 -- FOR TESTING
#   temp_city <- dict_location_crosswalk %>%
#     filter(place_GEOID == 1700243) %>%
#     pull(tract_GEOID)
#   
#   temp <- tracts_data %>%
#     filter(GEOID %in% temp_city) 
# 
#   # confirm pal_city works
# pal_city <- 
#   if(length(pull(temp, pwd_total)) < 4) {
#     colorNumeric(palette = "Yellow-Orange-Brown",
#                   domain = as.numeric(str_replace_all(city_tract$pwd_total, ",", "")))
#                  } else {
#     colorQuantile(palette = "Yellow-Orange-Brown",
#                   domain = as.numeric(str_replace_all(city_tract$pwd_total, ",", "")),
#                   n = 4)
#   }

  

######

  
  # Palette
pal_city <- reactive ({
  
  city_tract <- city_tract()
  city_tract_pwd_total <- as.numeric(str_replace_all(city_tract$pwd_total, ",", ""))
  map_palette <- access_map_palette_selected()

  if(length(city_tract_pwd_total) < 4) {
    colorNumeric(palette = map_palette,
                  domain = city_tract_pwd_total)
  } else {
    colorQuantile(palette = map_palette,
                  domain = city_tract_pwd_total,
                  n = 4)
  }
  
})

# Tract map
output$snapshotmap <- renderLeaflet({
  
  data <- left_join(
    city_tract_sf(),
    city_tract() %>% select(GEOID, pwd_total),
    by = c("tract_GEOID" = "GEOID")
  ) %>%
    mutate(pwd_total = as.numeric(str_replace_all(pwd_total, ",", "")))
  
  leaflet(data) %>%
    clearShapes() %>%
    addProviderTiles(providers$CartoDB.Positron) %>%
    addResetMapButton() %>%
    addPolygons(stroke = TRUE, color = "#444444",
                weight = 1, smoothFactor = 0,
                fillColor = ~pal_city()(pwd_total),
                fillOpacity = 0.5,
                layerId = ~ tract_GEOID) %>%
    addLegend(position = "topright", pal = pal_city(),
              values = ~ pwd_total,
              labFormat =  function(type, cuts, p) {
                n = length(cuts)
                paste0(as.numeric(cuts)[-n], " &ndash; ", as.numeric(cuts)[-1])
              },
              title = "# People With Disabilities") %>%
    addSearchOSM(options = searchOptions(autoCollapse = FALSE, minLength = 3,
                                         position = "topleft", zoom = 15,
                                         autoResize = FALSE,
                                         hideMarkerOnCollapse = TRUE))
  
})

withSpinner(leafletOutput("snapshotmap"))


```
:::

## Row

::: {role="region" aria-labelledby="section-city-summary"}
### 

```{r city-summary}

output$city_summary <- renderUI({
  
  create_number_percent_string <- function(num, pct) {
    
    #PCT requires special handling if it's NA because we want to construct it like " (NA%)"
    if(is.na(pct)) {
      pct_string <- " (NA%)"
    } else {
      pct_string <- paste0(" (",
                     scales::percent(as.numeric(pct), 
                        accuracy = 0.1,
                        scale = 1),
                     ")")
    }
    
    string <- paste0(num, pct_string)
    
    return(string)
  }
  
  # Overview text
  city_summary_text <- paste0(
    "<h5>People with Disabilities - Summary Tables</h5>",
    "Based on ACS 2022 5-Year Estimates, <b>", 
    city_place() %>%
      pull(pwd_total),
    "</b> of the city's <b>",
    city_place() %>%
      pull(pop_total),
    "</b> residents (<b>",
    city_place() %>%
      pull(pwd_pct),
    "%</b>) are people with disabilities.<br><br>")
  
  # # Summary tables side by side
  # # Create individual summary tables
  # # Demographics
  city_summary_demo <- city_place() %>%
    mutate(
      "White" = create_number_percent_string(pwd_white_nonhisp, pwd_white_nonhisp_dis_pct),
      "Black" =  create_number_percent_string(pwd_black, pwd_black_dis_pct),
      "Hispanic" = create_number_percent_string(pwd_hisp, pwd_hisp_dis_pct),
      "Asian" = create_number_percent_string(pwd_asian, pwd_asian_dis_pct),
      "Other" = create_number_percent_string(pwd_other_multiple, pwd_other_multiple_dis_pct),
      "<b>Total" =
        paste0(pwd_total,
               "</b>"),
      .keep = "none"
    ) %>%
    pivot_longer(everything(),
                 names_to = "Race/Ethnicity",
                 values_to = "PWD (%)") %>%
    mutate("Bullets" = paste0('<li>', `Race/Ethnicity`, " &mdash; ",
                              `PWD (%)`, '</li>')) %>%
    
    pull(Bullets) %>%
    str_c(collapse = "")

  # Poverty
    city_summary_poverty <- city_place() %>%
    mutate(
      "People With Disabilities Living In Poverty" = create_number_percent_string(pwd_below_poverty, pwd_below_poverty_pct),
      "People Without Disabilities Living In Poverty" =  create_number_percent_string(pwod_below_poverty, pwod_below_poverty_pct),
      .keep = "none"
    ) %>%
    pivot_longer(everything(),
                 names_to = "Race/Ethnicity",
                 values_to = "PWD (%)") %>%
    mutate("Bullets" = paste0('<li>', `Race/Ethnicity`, " &mdash; ",
                              `PWD (%)`, '</li>')) %>%

    pull(Bullets) %>%
    str_c(collapse = "")

  # # Community Participation
  city_summary_cp <- city_place() %>%
    mutate(
      "Car" = create_number_percent_string(pwd_car_commute, pwd_car_commute_pct),
      "Public Transit" =  create_number_percent_string(pwd_pub_transit, pwd_pub_transit_dis_pct),
      "Walk or Bike" = create_number_percent_string(pwd_walk_bike, pwd_walk_bike_pct),
      "<b>Total" =
        paste0(pwd_total_commute,
               "</b>"),
      .keep = "none"
    ) %>%
    pivot_longer(everything(),
                 names_to = "Transportation, Workers 16+",
                 values_to = "PWD (%)") %>%
    mutate("Bullets" = paste0('<li>', `Transportation, Workers 16+`, " &mdash; ",
                              `PWD (%)`, '</li>')) %>%
    pull(Bullets) %>%
    str_c(collapse = "")

  # # Work/Economic
  city_summary_we <- city_place() %>%
    mutate("Employed" = create_number_percent_string(pop_total_employed_16_plus, pwd_employed_subj),
              "Not in Labor Force" = create_number_percent_string(pwd_not_in_labor_force, pwd_not_employed_subj),
              "<b>Total" = paste0(pwd_16_plus_subj,"</b>"),
              .keep = "none") %>%
    pivot_longer(everything(),
                 names_to = "Employment, 16+",
                 values_to = "PWD (%)") %>%
    mutate("Bullets" = paste0('<li>', `Employment, 16+`, " &mdash; ",
                              `PWD (%)`, '</li>')) %>%

    pull(Bullets) %>%
    str_c(collapse = "")
  
  # Place dataframes in 3 columns side-by-side
  city_summary_tables <- paste0('<div class = "row">',
                                '<div class = "col-md-4">',
                                '<b>Race/Ethnicity</b><ul>',
                                city_summary_demo,
                                '</ul></div>',
                                '<div class = "col-md-4">',
                                '<b>Living In Poverty</b><ul>',
                                city_summary_poverty,
                                '</ul></div>',
                                '<div class = "col-md-4">',
                                '<b>Transportation, Workers 16+</b><ul>',
                                city_summary_cp,
                                '</ul></div>',
                                '<div class = "col-md-4">',
                                '<b>Employment, 16+</b><ul>',
                                city_summary_we,
                                '</ul></div>',
                                '</div>')
  
  
  
  # UI Output
  HTML(paste(city_summary_text, city_summary_tables, sep = ""))
  
})

withSpinner(uiOutput("city_summary"))

```
:::
:::

:::{role="main"}

# Community Reports
```{r community-living-scorecard-heat-test, echo=FALSE, message=FALSE, warning=FALSE}

# Read the first sheet
file_path <- "community_living_scorecard_heat_test.xlsx"
sheet1 <- read_excel(file_path, sheet = "Raw Data", skip = 0) 

# Rename columns to improve readability
colnames(sheet1) <- c("State", 
                      "% with a disability among head, spouse, co-head of household aged 61 and under: Public Housing", 
                      "% with a disability among head, spouse, co-head of household aged 61 and under: Housing Choice Vouchers",
                      "Expenditure Ratio for HCBS vs. Institution", 
                      "HCBS or Community Waiver Spending ($) per Medicaid Recipient ",
                      "% of People with a Disability Aged 18-64 Residing in Community",
                      "% of People with a Disability Aged 18-64 residing in Medical Institutions",
                      "% of People with Disabilities Residing in a Correctional Facility")

# Make the 'INDEX' column bold
sheet1 <- sheet1 %>%
  mutate(across(where(is.numeric), ~ round(., 2)))

# Display the data from the first sheet in a neat table format
sheet1 %>%
  kable("html", caption = "Raw Data - Community Living") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive"))

# Read the second sheet
sheet2 <- read_excel(file_path, sheet = "Index", skip = 0)

# Rename columns to improve readability
colnames(sheet2) <- c("State", 
                      "Head of Household in Public Housing 61 and under with a Disability", 
                      "Head of Household Housing Choice Vouchers 61 and under with a Disability",
                      "Ratio HCBS to instititutional expenditure",
                      "HCBS Spending on waivers(amount per medicaid recipient",
                      "PWD in Community Living (18-64 age)",
                      "PWD in Medical Institutions (18-64 age)",
                      "PWD in Correctional Facilities (18-64 age) ",
                      "INDEX")

# Make the 'INDEX' column bold
sheet2 <- sheet2 %>%
  mutate(across(where(is.numeric), ~ round(., 2))) %>%
  mutate(INDEX = cell_spec(INDEX, "html", bold = TRUE))

# Display the data from the second sheet in a neat table format
sheet2 %>%
  kable("html", escape = FALSE, caption = "Index - Community Living") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive"))

```


:::

:::{role="main"}

# About

```{r about_documentation}

# creating separate 'About' page per website re-design vision

```

Welcome to the ADA-PARC website. The ADA-PARC is a collaborative
research project of ten Americans with Disabilities Act (ADA) Regional
Centers.

<br>

#### Purpose of ADA-PARC

The ADA-PARC research has four purposes:

1.  **To look at participation disparities** experienced by people with
    disabilities post ADA & Olmstead
2.  **To identify & examine key environmental factors** contributing to
    these disparities
3.  **To benchmark participation disparities and highlight promising
    practices** at state & city levels
4.  **To action-plan strategies for dissemination and utilization of
    findings** to be used by ADA Centers and others in community
    capacity building & systems change initiatives

<br>

#### The Work of the ADA-PARC

The ADA-PARC has research teams focused on Community Living, Community
Participation & Work/Economic Participation measures and uses Regional
Steering Committees in each of the ten participating regions to gather,
review, and choose appropriate data to achieve the project's purposes.
The data are mainly from national data sources that have enough
statistical power to be relevant on the local level.

The intent of this effort is to use this information to inform:

1.  ADA Center technical assistance and resource dissemination, and
2.  Community level stakeholders to increase participation opportunities
    in their communities.

<br>

#### Who is the ADA-PARC

The ten participating ADA-Regional Centers in the ADA-PARC are:

-   Region 1 New England ADA Center
-   Region 2 Northeast ADA Center
-   Region 3 Mid-Atlantic ADA Center
-   Region 4 Southeast ADA Center
-   Region 5 Great Lakes ADA Center
-   Region 6 Southwest ADA Center
-   Region 7 Great Plains ADA Center
-   Region 8 Rocky Mountain ADA Center
-   Region 9 Pacific ADA Center
-   Region 10 Northwest ADA Center

Other institutions collaborating in the ADA-PARC are:

-   The ADA Knowledge Translation Center
-   The Center on Disability at the Public Health Institute
-   TIRR Memorial Hermann
-   Syracuse University
-   The University of Illinois at Chicago
-   The University of Northern Colorado

<br>

<img src="./www/participant_logos.png" alt="The ten participating ADA-Regional Centers" width="75%"/>

<br>

The ADA-PARC website is a collection of public data sets that can help
shed light on the status of people with disabilities in local
communities. The data includes national, state, county, and city data.
In addition to Demographic data describing the population, the three
main areas of data to illuminate the status of disability in an area
are: Community Living, Community Participation and Work & Economics.
Each of the three areas presents data in map form as well as in tabular
form. A summary of what is important about the data is presented on each
page. The data source is described along with the calculation to arrive
at the values used in the tables and maps. Data is first presented by
state, and then if available, at county and city level.

The ADA Participation Action Consortium is funded by the National
Institute on Disability, Independent Living, and Rehabilitation Research
(NIDILRR) (90DP0026 and 90DPAD0001). NIDILRR is a Center within the
Administration for Community Living (ACL), Department of Health and
Human Services (HHS). The contents of this website do not necessarily
represent the policy of NIDILRR, ACL, HHS, and you should not assume
endorsement by the Federal Government.

:::

# Settings

::: {role="main"}
###  {.long-row}

```{r accessibility-page-body}

# Map palette
access_map_palette_choices <- list(
  "Yellow-Orange-Brown" = "YlOrBr", 
  "Yellow-Orange-Red" = "YlOrRd", 
  "Green-Blue" = "GnBu")

selectInput(inputId = "access_map_palette",
            label = h5("Select a color palette for maps:"),
            choices = names(access_map_palette_choices),
            selected = "Yellow-Orange-Brown")

access_map_palette_selected <- reactive({
  access_map_palette_choices[[input$access_map_palette]] })

# GGplot themes and colors
access_ggplot_theme_choices <- list(
  "The Economist" = list(theme_economist(), scale_fill_economist(), scale_color_economist()),
  "Five Thirty Eight" = list(theme_fivethirtyeight(), scale_fill_economist(), scale_color_fivethirtyeight()),
  "Highcharts" = list(theme_hc(), scale_fill_hc(), scale_color_hc()),
  "Ipsum" = list(theme_ipsum(), scale_fill_colorblind(), scale_color_colorblind()),
  "Light" = list(theme_light(), scale_fill_colorblind(), scale_color_colorblind()),
  "Minimal" = list(theme_minimal(),scale_fill_ordinal(), scale_color_ordinal()),
  "Stata" = list(theme_stata(), scale_fill_stata(), scale_color_stata()))

# Hide selector for now since city data plots are excluded
# selectInput(inputId = "access_ggplot_theme", 
#             label = h5("Select a theme for plots:"), 
#             choices = names(access_ggplot_theme_choices),
#             selected = "Ipsum")

ggplot_theme_selected <- reactive({ access_ggplot_theme_choices[[input$access_ggplot_theme]][1] })
ggplot_fill_selected <- reactive({ access_ggplot_theme_choices[[input$access_ggplot_theme]][2] }) 
ggplot_color_selected <- reactive({ access_ggplot_theme_choices[[input$access_ggplot_theme]][3] }) 

```
:::

<!-- Custom Javascript  -->

```{=html}
<script>
$("body").on("shown.bs.tab", "a[data-toggle='tab']", function(e) {
Shiny.setInputValue("active_tab", $(e.target).parent().index());
})
</script>
```
<!-- CSS for dashboard  -->

```{=html}
<style type="text/css">

/* #################### */
/* Fonts */
/* #################### */

/* Headers */
h2,h3,h4,h5 { 
font-weight: bold;
}

/* Section title color */
h3 { 
color: black;
}

/* #################### */
/* Coloring */
/* #################### */

/* Leaflet border */
.leaflet .legend i{
border-left:1px solid #000000;
border-right:1px solid #000000;
border-top:1px solid #000000;
border-bottom:1px solid #000000;
}

/* Leaflet background */
.leaflet-container {
background: #ddd;
}

/* Section dividers */
.section-divider { 
background-color: #CCCCCC;
color: #000000;
}

/* Selector widget Active Option */
.item {
background: white !important;
color: black !important;
}
.selectize-dropdown-content .active {
background: #EFEFEF !important;
color: black !important;
border-left:1px solid #000000;
border-right:1px solid #000000;
border-top:1px solid #000000;
border-bottom:1px solid #000000;
}

/* Kable caption colors (darken to meet contrast requirements) */
caption {
color: black;
font-weight: bold;
}


/* #################### */
/* Containers */
/* #################### */

/* Set max length for dropdowns */
.selectize-dropdown-content {
padding: 10px;
}

/* Allow dropdowns to be visible for short containers */
#access_ggplot_theme+ div>.selectize-dropdown, #access_map_palette+ div>.selectize-dropdown {
position: static;
}

/* Have dropdowns display on top of Leaflet */
.selectize-dropdown {
z-index: 10000;
overflow-y: auto;
}

/* Scroll overflow for tables */
.table-wrapper {
overflow-x: scroll;
overflow-y: scroll;
}

</style>
```




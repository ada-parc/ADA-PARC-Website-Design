---
title: "ADA-PARC"
output:
  flexdashboard::flex_dashboard:
    orientation: rows
    vertical_layout: fill
    theme: cosmo
    includes:
      in_header: www/cssloaders.html
    css: www/styles.css
runtime: shiny
resource_files:
- www/participant_logos.png
- scripts/functions.R
- data/dict_vars.csv
- data/final/city_place_full.Rds
- data/final/community_living.Rds
- data/final/community_participation.Rds
- data/final/demographics.Rds
- data/final/dict_location_crosswalk.Rds
- data/final/tract_data.Rds
- data/final/tracts_sf.Rds
- data/final/work_economic.Rds
---

```{r setup, include=FALSE}

### ----- Libraries -----

# Install from devtools non-CRAN packages as needed
# devtools::install_github("daattali/shinycssloaders", ref = "rmarkdown") # rmarkdown branch must be installed and cssloaders_in_header.html must exist
library(devtools)
# devtools::install_github("UrbanInstitute/urbnmapr")

# Packages
library(reactlog)
library(tidyverse)
library(patchwork)
library(kableExtra)
library(tigris); library(sf)
library(urbnmapr)
library(leaflet); library(leaflet.extras)
library(htmltools)
library(shiny); library(shinycssloaders)
library(shinyWidgets); library(flexdashboard)
library(colourpicker)
library(scales)
library(tableHTML)
library(hrbrthemes); library(ggthemes)
library(extrafont)

options(scipen = 999999,
        tigris_use_cache = TRUE,
        shiny.reactlog = TRUE)
knitr::opts_chunk$set(fig.cap = TRUE)

#################################
#################################
# Load data:
#################################
#################################
city_place_full <- readRDS(here::here("data", "final", "city_place_full.Rds")) 

community_living <- readRDS(here::here("data", "final", "community_living.Rds")) 

community_participation <- readRDS(here::here("data", "final", "community_participation.Rds"))

demographics <- readRDS(here::here("data", "final", "demographics.Rds"))

dict_location_crosswalk <- readRDS(here::here("data", "final", "dict_location_crosswalk.Rds")) 
tracts_data <- readRDS(here::here("data", "final", "tracts_data.Rds")) 

work_economic <- readRDS(here::here("data", "final", "work_economic.Rds"))

tracts_sf <- readRDS(here::here("data", "final", "tracts_sf.Rds"))


# Read in variable dictionary manually
dict_vars <- read_csv(here::here("data", "dict_vars.csv"))

### ----- Functions import -----


# Load API keys and database connection information
source(here::here("scripts", "functions.R"), local = TRUE)

```

# Home

## Sidebar {.sidebar}

<br>

#### How to Navigate<br>this Website
<br>
Use the **National Data** tab to examine the status of people with disabilities at the national and state level.

Use the **City Data** tab to investigate people with disabilities statistics at the municipal level.

Use the **Accessibility** tab to set color palettes for the visualizations in this dashboard.

<br>

**Questions?** <br>
[Contact Joy Hammel (email)](mailto:hammel@uic.edu) <br>
Director of Graduate Studies <br>
UIC College of Applied Health Sciences

Application authors: <br>
Ethan Jantz, Sean Connelly, Jane Huber, and Randy D. Col√≥n <br>
[UIC Voorhees Center](https://voorheescenter.uic.edu/)

<div role="main">

## Row

### 

<br>

Welcome to the ADA-PARC website. The ADA-PARC is a collaborative research project of ten Americans with Disabilities Act (ADA) Regional Centers.

<br>

#### Purpose of ADA-PARC

The ADA-PARC research has four purposes:

1.  **To look at participation disparities** experienced by people with disabilities post ADA & Olmstead
2.  **To identify & examine key environmental factors** contributing to these disparities
3.  **To benchmark participation disparities and highlight promising practices** at state & city levels
4.  **To action-plan strategies for dissemination and utilization of findings** to be used by ADA Centers and others in community capacity building & systems change initiatives

<br>

#### The Work of the ADA-PARC

The ADA-PARC has research teams focused on Community Living, Community Participation & Work/Economic Participation measures and uses Regional Steering Committees in each of the ten participating regions to gather, review, and choose appropriate data to achieve the project's purposes. The data are mainly from national data sources that have enough statistical power to be relevant on the local level.

The intent of this effort is to use this information to inform:

1.  ADA Center technical assistance and resource dissemination, and
2.  Community level stakeholders to increase participation opportunities in their communities.

<br>

#### Who is the ADA-PARC

The ten participating ADA-Regional Centers in the ADA-PARC are:

-   Region 1 New England ADA Center
-   Region 2 Northeast ADA Center
-   Region 3 Mid-Atlantic ADA Center
-   Region 4 Southeast ADA Center
-   Region 5 Great Lakes ADA Center
-   Region 6 Southwest ADA Center
-   Region 7 Great Plains ADA Center
-   Region 8 Rocky Mountain ADA Center
-   Region 9 Pacific ADA Center
-   Region 10 Northwest ADA Center

Other institutions collaborating in the ADA-PARC are:

-   The ADA Knowledge Translation Center
-   The Center on Disability at the Public Health Institute
-   TIRR Memorial Hermann
-   Syracuse University
-   The University of Illinois at Chicago
-   The University of Northern Colorado

<br>

<img src="./www/participant_logos.png" alt="The ten participating ADA-Regional Centers" width="75%">

<br>

#### About this Website

The ADA-PARC website is a collection of public data sets that can help shed light on the status of people with disabilities in local communities. The data includes national, state, county, and city data. In addition to Demographic data describing the population, the three main areas of data to illuminate the status of disability in an area are: Community Living, Community Participation and Work & Economics. Each of the three areas presents data in map form as well as in tabular form. A summary of what is important about the data is presented on each page. The data source is described along with the calculation to arrive at the values used in the tables and maps. Data is first presented by state, and then if available, at county and city level.

The ADA Participation Action Consortium is funded by the National Institute on Disability, Independent Living, and Rehabilitation Research (NIDILRR) (90DP0026 and 90DPAD0001). NIDILRR is a Center within the Administration for Community Living (ACL), Department of Health and Human Services (HHS). The contents of this website do not necessarily represent the policy of NIDILRR, ACL, HHS, and you should not assume endorsement by the Federal Government.

</div>

<div role="main">

# National Data

<div role="region" aria-labelledby="sidebar">

## Sidebar {.sidebar}

<br>

To explore the data first select a category and then a topic. You can navigate the boxes below using the mouse or keyboard. For keyboard users, once the box is highlighted you can press backspace and begin typing the selection into the box.

```{r national-sidebar, context="server", message=FALSE, warning=FALSE, fig.alt = "A sidebar containing two drop down menus. One selects a category, and the other selects a topic within that category. These other elements of this page will change based on the selected category and topic."}


### ----- Category selector ------

# National category selection widget
national_category_choices <- c(
  "Demographics" = "is_demographics", 
  "Community Participation" = "is_community_participation", 
  "Community Living" = "is_community_living", 
  "Work/Economic" = "is_work_economic"
)

# Select the data frame to use
selectInput(inputId = "national_category_selector", 
            label = "Select a category", 
            choices = names(national_category_choices),
            selected = "is_demographics",
            multiple = FALSE)

# Selected category for function inputs
# Output looks like "is_demographics"
national_category_selected <- reactive({ 
  
  getElement(national_category_choices, input$national_category_selector)
  
})


### ----- National data  ------


# Select dataframe for national data tab
national_data <- reactive({
  
  eval(sym(str_remove(national_category_selected(), "^is_")))
  
})


### ----- Variable selector  ------


# National variable selection choices, based on category
national_variable_choices <- reactive({
  
  tibble::deframe(
    dict_vars %>%
      filter(!!sym(national_category_selected()) == TRUE,
             var_readable %in% (
               national_data() %>%
                 select(-c(GEOID, NAME, ABBR)) %>%
                 names()
             ),
             !is.na(national_dropdown_label)) %>%
      select(national_dropdown_label, var_readable)
  )
  
})

# National variable selection widget, default options
selectInput(inputId = "national_variable_selector",
            label = "Select a topic",
            choices = tibble::deframe(c("Population", "pop_total")),
            selected = "pop_total",
            multiple = FALSE)

# Update variable selections when category changes
observeEvent(input$national_category_selector, {
  
  choices <- names(national_variable_choices())
  
  updateSelectInput(session, "national_variable_selector",
                    choices = choices, 
                    selected = choices[1])
  
})

# Try debouncing, didn't fire early enough
# national_variable_selector_db <- debounce(reactive({input$national_variable_selector}), 2000)

# Selected variable for function inputs
# Output looks like "pop_total"
national_variable_selected <- reactive({ 
  
  # req(national_variable_selector_db())
  req(national_category_selected())
  
  getElement(national_variable_choices(), input$national_variable_selector)
  
})

### For debugging
# renderText({ is.null(national_category_selected()) })
# renderText({ is.null(national_variable_selected()) })
# renderText({ national_category_selected() })
# renderText({ national_variable_selected() })
# renderText({ national_variable_choices() })


### ----- Summary text  ------


# Summary text
output$national_map_summary <- renderUI({
  
  HTML(
    paste0(
      altText(national_data(), 
              national_variable_selected()),
      " Detailed information is available to the right in the interactive map (top) and table (bottom).<br><br>Source: 2017-2021 American Community Survey five-year estimates")
  )
  
})

withSpinner(uiOutput("national_map_summary"))

```

</div>

## Row {data-height=100}

<div role="region" aria-labelledby="section-national-title">

### National Map Title

```{r national-map-title, fig.alt = "Map title the selected topic."}

output$national_map_title <- renderUI({

  HTML(
      altTitle(national_variable_selected())
      
    # # Static check
    # altTitle(demographics,
    #         national_variable_selector_static)

  )

})

withSpinner(uiOutput("national_map_title"))

```

</div>

## Row

<div role="region" aria-labelledby="section-state-by-state-map-of-selected-topic">

### State-by-State Map of Selected Topic

```{r national-map, out.width = "100%", fig.align = "center", fig.cap= "A map of the United States, with each state shaded according to the quartiles described in the summary.", fig.alt= "A map of the United States, with each state shaded according to the quartiles described in the summary."}

output$national_map <- renderUI({
  
  withSpinner(plotOutput("national_ggmap"))
  
})

uiOutput("national_map")

output$national_ggmap <- renderPlot({
  
  render_national_map(national_category_selected(),
                      national_variable_selected(), 
                      access_map_palette_selected())
  
})

# For debugging
# Static version of comparison map
# render_national_map(                          
#   "is_demographics",
#   "pwd_pct",
#   "YlOrBr"
# )

# output$national_tmap <- renderPlot({
#   #   # req(national_variable_selected(), national_category_selected(), national_data())
#   #   print("reqs filled")
#   #   print("run tmap")
#   render_national_map(national_category_selected(),
#                       national_variable_selected(),
#                       access_map_palette_selected())
#   #   
# })

```

</div>

## Row

<div role="region" aria-labelledby="section-table-of-selected-topic">

### Table of Selected Topic {.table-wrapper}

```{r national-table, fig.alt = "Data table including state-level data for variables relevant to the selected topic."}

# Get variable group based on selected variable
national_vars_in_topic <- reactive({
  
  dict_vars %>% 
    filter((!!sym(national_category_selected())) == TRUE,
           var_topic ==
             (dict_vars %>% 
                filter((!!sym(national_category_selected())) == TRUE &
                       var_readable == national_variable_selected()) %>% 
                pull(var_topic)),
           display == T) %>% 
    select(var_pretty, var_readable)
  
  # # Static check
  # national_vars_in_topic_static <- dict_vars %>%
  #   filter(is_demographics == TRUE,
  #          var_topic ==
  #          (dict_vars %>%
  #             filter(is_demographics == TRUE,
  #                    var_readable == "pwd_18_64_pct") %>%
  #             pull(var_topic))) %>%
  #   select(var_pretty, var_readable)
  
})

# Caption
cap_choices <- c("Demographics" = "is_demographics", 
                 "Community Participation" = "is_community_participation", 
                 "Community Living" = "is_community_living", 
                 "Work/Economic" = "is_work_economic")

table_caption <- reactive({
  
  paste(names(cap_choices[cap_choices == national_category_selected()]), "Table")
  
})

# Reorganize dataframe, switch to pretty names
national_data_table_friendly <- reactive({
  
  national_data() %>%
    arrange(GEOID) %>% 
    mutate("State" = paste0(NAME
    )
    ) %>% 
    select(any_of(c("State",
                    national_vars_in_topic() %>% 
                      pull(var_readable)))) %>% 
    mutate(across(ends_with("_pct"),
                  ~scales::percent(.x,
                                   accuracy = 0.1,
                                   scale = 1))) %>%
    rename(!!any_of(national_vars_in_topic() %>% 
                      deframe())) %>%
    select(State, starts_with("Population"), starts_with("Percent"), everything())
  
  # # Static check
  # table_friendly <- demographics %>%
  #   mutate("State" = paste0(NAME
  #                           # " (", ABBR, ")"
  #                           )) %>%
  #   select(any_of(c("State",
  #                   national_vars_in_topic_static %>%
  #                     pull(var_readable)))) %>%
  #   mutate(across(-State & -ends_with("_pct"),
  #                 ~scales::comma(.x))) %>%
  #   mutate(across(ends_with("_pct"),
  #                 ~scales::percent(.x,
  #                                  accuracy = 0.1,
  #                                  scale = 1))) %>%
  #   rename(!!any_of(national_vars_in_topic_static %>%
  #                     deframe()))
  
})

# UI Output
output$national_table <- renderUI({ 
  
  # This is incredibly hacky
  # But I can't find a better way to make these
  # tables accessible at this point in time
  HTML(
    tableHTML(national_data_table_friendly() %>% 
                mutate(State = paste0(State, "a")), rownames = F, class = "table_national") %>% 
      # Essentially, this respecifies the first column as a column of table headers. See link below
      # https://www.w3.org/WAI/tutorials/tables/two-headers/
      replace_html('<td id="tableHTML_column_1">', '<th scope="row" id="tableHTML_column_1">', replace_all = T) %>% 
      replace_html('[a-z]</td>', '</th>', replace_all = T)
  )
  
  # Static check
  # HTML(
  #   tableHTML(table_friendly %>%
  #               mutate(State = paste0(State, "a")),
  #             rownames = F, class = "table_national") %>%
  #     # Essentially, this respecifies the first column as a column of table headers. See link below
  #     # https://www.w3.org/WAI/tutorials/tables/two-headers/
  #     replace_html('<td id="tableHTML_column_1">', '<th scope="row" id="tableHTML_column_1">', replace_all = T) %>%
  #     replace_html('[a-z]</td>', '</th>', replace_all = T)
  # )
  
})

withSpinner(uiOutput("national_table"))

```

</div>

</div>

<div role="main">

# City Data

## Sidebar {.sidebar}

To explore the data select a city below. You can navigate the selection boxes using the mouse or keyboard. For keyboard users, once the box is highlighted you can press backspace and begin typing the selection into the box. A state must be selected first.


```{r city-sidebar}

# Define inputs, restrict to cities in database

state_choices <- tibble(NAME = state.name, ABB =  state.abb) %>%
  add_row(NAME = c("District of Columbia", "Puerto Rico"),
          ABB = c("DC", "PR")) %>%
  deframe()

selectInput(inputId = "state_selector",
            label = "Select a state",
            choices = state_choices,
            selected = state_choices[13])

state_selected <- reactive({
  state_choices[which(state_choices == input$state_selector)]
})

# City choices, based on state, remove CDPs for now
city_choices <- reactive({
  
  tibble::deframe(
    dict_location_crosswalk %>%
      filter(state == state_selected(),
             !str_detect(place_NAME, " CDP")) %>%
      select(place_NAME, state, place_GEOID) %>%
      distinct(place_NAME, place_GEOID)
  ) %>%
    sort()
  
})

selectInput(inputId = "city_selector", 
            label = "Select a city", 
            choices =   tibble::deframe(
    dict_location_crosswalk %>%
      filter(state == "IL") %>%
      select(place_NAME, state, place_GEOID) %>%
      distinct(place_NAME, place_GEOID)
  ),
            selected = "1714000")

# Update variable selections when category changes
observeEvent(input$state_selector, {
  
  choices <- names(city_choices())
  
  updateSelectInput(session, "city_selector",
                    choices = choices, 
                    selected = choices[2])
  
})

city_selected <- reactive({ 
  
  # req(national_variable_selector_db())
  req(state_selected())
  
  getElement(city_choices(), input$city_selector)
  
})

### ----- Pull Census Place data for selected city -----

# Place for selected city
city_place <- reactive({

  city_place_geoids <- city_place_full%>% 
    filter(GEOID == city_selected())
   
  length_city_place <- nrow(city_place_geoids)
  
  
  cat("City place full: ", length_city_place, "the list <</br>")
  
    city_place_full %>% 
    filter(GEOID == city_selected())
  
})

### ----- Pull Census Tract data for selected city -----

# Spatial
city_tract_sf <- reactive({
  
  # Restrict tract call to selected city
  temp_city <- dict_location_crosswalk %>% 
    filter(place_GEOID %in% city_selected()) %>% 
    pull(tract_GEOID)
  
  temp_sf <- tracts_sf %>%
    filter(tract_GEOID %in% temp_city)
  
  return(temp_sf)
  
})

# Tabular
city_tract <- reactive ({
  
  temp_city <- dict_location_crosswalk %>%
    filter(place_GEOID %in% city_selected()) %>%
    pull(tract_GEOID)
  
  cat(paste0("Selected City tracts from Place: ", temp_city, "<br>"))
  
  temp <- tracts_data %>%
    filter(GEOID %in% temp_city) 
  
  length_temp <- nrow(temp)
  
    cat(paste0("Tracts Data Length: ", length_temp, "<br>"))

  # # Connect and pull
  # temp_mongo_conn <- fun_mongo_connect(host_name,
  #                                      collection_name = "acs_tract_S1810",
  #                                      database_name = "ADA-PARC")
  # temp <- temp_mongo_conn$find(
  #   query = sprintf('{ "GEOID" : { "$in" : [  "%s" ] } }' ,
  #                   str_c(city_tract_sf()$t_GEOID, collapse = '", "')))
  return(temp)
  
})

```

## Row

<div role="region" aria-labelledby="section-city-summary">

### City Summary

```{r city-summary}

output$city_summary <- renderUI({
  
  # Overview text
  city_summary_text <- paste0(
    "<h4>",  
    city_place() %>% 
      mutate(NAME = str_replace_all(NAME, pattern = " (city|village|municipality|town), ", replacement = ", ")) %>% 
      pull(NAME), "</h4>",
    "Based on ACS 2021 5-Year Estimates, <b>", city_place() %>% 
      pull(pwd_total) %>% 
      scales::comma(.), "</b> of the city's <b>", 
    city_place() %>% 
      pull(pop_total) %>% 
      scales::comma(.), "</b> residents (<b>", 
    city_place() %>% 
      pull(pwd_pct),
    "%</b>) are people with disabilities.<br><h5>People with Disabilities - Summary Tables</h5>")
  
  # Summary tables side by side
  # Create individual summary tables
  # Demographics
  city_summary_demo <- city_place() %>%
    mutate("White" = paste0(comma(pwd_white_nonhisp,
                                  accuracy = 1),
                            " (", pwd_white_nonhisp_pct, "%)"),
           "Black" = paste0(comma(pwd_black,
                                  accuracy = 1),
                            " (", pwd_black_pct, "%)"),
           
           "Hispanic" = paste0(comma(pwd_hisp,
                                  accuracy = 1),
                            " (", pwd_hisp_pct, "%)"),
           "Asian" = paste0(comma(pwd_asian,
                      accuracy = 1),
                " (", pwd_asian_pct, "%)"),
           "Other" = paste0(comma(pwd_other,
                      accuracy = 1),
                " (", pwd_other_pct, "%)"),
           "<b>Total" =
                paste0(comma(pwd_total,
                             accuracy = 1),
                       "</b>"),
           .keep = "none") %>% 
    pivot_longer(everything(),
                 names_to = "Race/Ethnicity",
                 values_to = "PWD (%)") %>%
    mutate("Bullets" = paste0('<li>', `Race/Ethnicity`, " &mdash; ",
                              `PWD (%)`, '</li>')) %>%
    
    pull(Bullets) %>% 
    str_c(collapse = "")
           

  # Community Participation
  city_summary_cp <- city_place() %>%
    mutate("Car" =
                paste0(comma(pwd_car_commute,
                             accuracy = 1),
                       " (", comma(pwd_car_commute_pct,
                                   accuracy = 0.1), "%)"),
              "Transit" =
                paste0(comma(pwd_pub_transit,
                             accuracy = 1),
                       " (", comma(pwd_pub_transit_pct,
                                   accuracy = 0.1), "%)"),

              "Walk or Bike" =
                paste0(comma(pwd_walk_bike,
                             accuracy = 1),
                       " (", comma(pwd_walk_bike_pct,
                                   accuracy = 0.1), "%)"),
              "Work from Home" =
                paste0(comma(pwd_wfh,
                             accuracy = 1),
                       " (", comma(pwd_wfh_pct,
                                   accuracy = 0.1), "%)"),
              "<b>Total" =
                paste0(comma(pwd_total_commute,
                             accuracy = 1),
                       "</b>"),
                .keep = "none") %>% 
    pivot_longer(everything(),
                 names_to = "Commute, Workers 16+",
                 values_to = "PWD (%)") %>%
    mutate("Bullets" = paste0('<li>', `Commute, Workers 16+`, " &mdash; ",
                              `PWD (%)`, '</li>')) %>%

    pull(Bullets) %>%
    str_c(collapse = "")

  # # Work/Economic
  city_summary_we <- city_place() %>%
    mutate("Employed" =
                paste0(comma(pop_total_employed_16_plus, accuracy = 1),
                       " (", pwd_employed_subj, "%)"),
              "Not in Labor Force" =
                paste0(comma((pwd_16_plus_subj - pop_total_employed_16_plus), accuracy = 1),
                       " (", pwd_not_employed_subj, "%)"),
              "<b>Total" =
                paste0(comma(pwd_16_plus_subj, accuracy = 1),
                       "</b>"),
              .keep = "none") %>% 
    pivot_longer(everything(),
                 names_to = "Employment, 16+",
                 values_to = "PWD (%)") %>%
    mutate("Bullets" = paste0('<li>', `Employment, 16+`, " &mdash; ",
                              `PWD (%)`, '</li>')) %>%

    pull(Bullets) %>%
    str_c(collapse = "")
  
  # Place dataframes in 3 columns side-by-side
  city_summary_tables <- paste0('<div class = "row">',
                                '<div class = "col-md-4">',
                                '<b>Race/Ethnicity</b><ul>',
                                city_summary_demo,
                                '</ul></div>',
                                '<div class = "col-md-4">',
                                '<b>Commute, Workers 16+</b><ul>',
                                city_summary_cp,
                                '</ul></div>',
                                '<div class = "col-md-4">',
                                '<b>Employment, 16+</b><ul>',
                                city_summary_we,
                                '</ul></div>',
                                '</div>')
  
  
  
  # UI Output
  HTML(paste(city_summary_text, city_summary_tables, sep = ""))
  
})

withSpinner(uiOutput("city_summary"))

```

</div>

## Row

<div role="region" aria-labelledby="section-people-with-disabilities-map">

### People With Disabilities Map

```{r city-pwd-map, fig.alt="Map of people with disabilities by census tract in the selected city", context="server"}

# Palette
pal_city <- reactive ({
  if(length(pull(city_tract(), pwd_total)) < 4) {
    colorNumeric(palette = access_map_palette_selected(),
                 domain = pull(city_tract(), pwd_total))
  } else {
    colorQuantile(palette = access_map_palette_selected(),
                  domain = pull(city_tract(), pwd_total),
                  n = 4)
  }
  
})

# Tract map
output$snapshotmap <- renderLeaflet({
  
  data <- left_join(city_tract_sf(),
                    city_tract() %>% select(GEOID, pwd_total),
                    by = c("tract_GEOID" = "GEOID")) 
  
  leaflet(data) %>%
    clearShapes() %>%
    addProviderTiles(providers$Esri, group = "Esri") %>%
    addProviderTiles(providers$CartoDB.Positron, group = "CartoDB") %>%
    addResetMapButton() %>%
    addPolygons(stroke = TRUE, color = "#444444",
                weight = 1, smoothFactor = 0,
                fillColor = ~pal_city()(pwd_total),
                fillOpacity = 0.5,
                layerId = ~ tract_GEOID) %>%
    addLegend(position = "topright", pal = pal_city(),
              values = ~ pwd_total,
              labFormat =  function(type, cuts, p) {
                n = length(cuts)
                paste0(as.numeric(cuts)[-n], " &ndash; ", as.numeric(cuts)[-1])
              },
              title = "PWD") %>%
    addLayersControl(position = "bottomright",
                     baseGroups = c("Esri", "CartoDB"),
                     options = layersControlOptions(collapsed = FALSE)) %>%
    addSearchOSM(options = searchOptions(autoCollapse = FALSE, minLength = 3,
                                         position = "topleft", zoom = 15,
                                         autoResize = FALSE,
                                         hideMarkerOnCollapse = TRUE))
  
})

# # Click event for the map
# click_snapshotmap <- eventReactive(input$snapshotmap_shape_click, {
#   
#   x <- input$snapshotmap_shape_click
#   y <- x$id
#   
#   return(y)
#   
# })

# # Add the clicked state to the map, and remove when a new one is clicked
# observe({
#   
#   req(click_snapshotmap())
#   
#   snapshotmap <- leafletProxy("snapshotmap") %>%
#     removeShape("highlight_tract") %>%
#     addPolygons(data = city_tract_sf()[city_tract_sf()$GEOID == click_snapshotmap(), ], 
#                 fill = FALSE, weight = 3,
#                 color = "#000000", opacity = 1, layerId = "highlight_tract")
#   
# })

withSpinner(leafletOutput("snapshotmap"))


```

</div>

</div>

# Accessibility

<div role="main">

###  {.long-row}

```{r accessibility-page-body}

# Map palette
access_map_palette_choices <- list(
  "Yellow-Orange-Brown" = "YlOrBr", 
  "Yellow-Orange-Red" = "YlOrRd", 
  "Green-Blue" = "GnBu")

selectInput(inputId = "access_map_palette",
            label = h5("Select a color palette for maps:"),
            choices = names(access_map_palette_choices),
            selected = "Yellow-Orange-Brown")

access_map_palette_selected <- reactive({
  access_map_palette_choices[[input$access_map_palette]] })

# GGplot themes and colors
access_ggplot_theme_choices <- list(
  "The Economist" = list(theme_economist(), scale_fill_economist(), scale_color_economist()),
  "Five Thirty Eight" = list(theme_fivethirtyeight(), scale_fill_economist(), scale_color_fivethirtyeight()),
  "Highcharts" = list(theme_hc(), scale_fill_hc(), scale_color_hc()),
  "Ipsum" = list(theme_ipsum(), scale_fill_colorblind(), scale_color_colorblind()),
  "Light" = list(theme_light(), scale_fill_colorblind(), scale_color_colorblind()),
  "Minimal" = list(theme_minimal(),scale_fill_ordinal(), scale_color_ordinal()),
  "Stata" = list(theme_stata(), scale_fill_stata(), scale_color_stata()))

# Hide selector for now since city data plots are excluded
# selectInput(inputId = "access_ggplot_theme", 
#             label = h5("Select a theme for plots:"), 
#             choices = names(access_ggplot_theme_choices),
#             selected = "Ipsum")

ggplot_theme_selected <- reactive({ access_ggplot_theme_choices[[input$access_ggplot_theme]][1] })
ggplot_fill_selected <- reactive({ access_ggplot_theme_choices[[input$access_ggplot_theme]][2] }) 
ggplot_color_selected <- reactive({ access_ggplot_theme_choices[[input$access_ggplot_theme]][3] }) 

```

</div>

<!-- Custom Javascript  -->

```{=html}
<script>
$("body").on("shown.bs.tab", "a[data-toggle='tab']", function(e) {
Shiny.setInputValue("active_tab", $(e.target).parent().index());
})
</script>
```

<!-- CSS for dashboard  -->

```{=html}
<style type="text/css">

/* #################### */
/* Fonts */
/* #################### */

/* Headers */
h2,h3,h4,h5 { 
font-weight: bold;
}

/* Section title color */
h3 { 
color: black;
}

/* #################### */
/* Coloring */
/* #################### */

/* Leaflet border */
.leaflet .legend i{
border-left:1px solid #000000;
border-right:1px solid #000000;
border-top:1px solid #000000;
border-bottom:1px solid #000000;
}

/* Leaflet background */
.leaflet-container {
background: #ddd;
}

/* Section dividers */
.section-divider { 
background-color: #CCCCCC;
color: #000000;
}

/* Selector widget Active Option */
.item {
background: white !important;
color: black !important;
}
.selectize-dropdown-content .active {
background: #EFEFEF !important;
color: black !important;
border-left:1px solid #000000;
border-right:1px solid #000000;
border-top:1px solid #000000;
border-bottom:1px solid #000000;
}

/* Kable caption colors (darken to meet contrast requirements) */
caption {
color: black;
font-weight: bold;
}


/* #################### */
/* Containers */
/* #################### */

/* Set max length for dropdowns */
.selectize-dropdown-content {
padding: 10px;
}

/* Allow dropdowns to be visible for short containers */
#access_ggplot_theme+ div>.selectize-dropdown, #access_map_palette+ div>.selectize-dropdown {
position: static;
}

/* Have dropdowns display on top of Leaflet */
.selectize-dropdown {
z-index: 10000;
overflow-y: auto;
}

/* Scroll overflow for tables */
.table-wrapper {
overflow-x: scroll;
overflow-y: scroll;
}

</style>
```

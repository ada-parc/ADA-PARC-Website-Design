---
title: "ADA-PARC American Community Survey Download Tool"
output:
  html_document:
    toc: TRUE
    toc_float: TRUE
    toc_depth: 4
    code_folding: hide
editor_options: 
  chunk_output_type: console
runtime: shiny
---

```{r setup, include=FALSE}

# Libraries
library(tidyverse);library(readxl);library(openxlsx)
library(tigris);library(sf);library(janitor)
library(tidycensus);library(viridis);library(tmap)
library(RPostgres);library(RPostgreSQL);library(DBI)
library(geojsonsf);library(mongolite);library(config)
library(shiny);library(shinyjs);library(shinyWidgets)

# Set working dictionary, options
setwd(here::here())
options(stringsAsFactors = FALSE, scipen = 999, 
        dplyr.summarise.inform = FALSE, tigris_use_cache = TRUE)
knitr::opts_chunk$set(echo = FALSE)

# Load API keys and database connection information
source("functions.R", local = TRUE)

```

## **Background**

This interactive walkthrough tool allows users to upload specific American Community Survey (ACS) data related to people with disabilities to the MongoDB database powering the [ADA-PARC Data Dashboard](https://ada-parc.shinyapps.io/ada_parc/). The rest of the document is organized by the various geographies used in the ADA-PARC dashboard: States, Cities (or Places), and Tracts.

## **States**

#### **Select Variables**

Use the following inputs to download ACS data at the state level. This script uses Kyle Walker's tidycensus package to access US Census Bureau APIs. Please consult the [tidycensus documentation](https://cran.r-project.org/web/packages/tidycensus/tidycensus.pdf) for additional information and options. 

```{r states-acs-input}

# Dataset
selectInput(inputId = "states_acs_dataset",
            label = "Select a dataset:",
            choices = list(`5-Year ACS` = list("5-Year: Default (Detailed)" = "acs5",
                                               "5-Year: Subject" = "acs5/subject", 
                                               "5-Year: Profile" = "acs5/profile"),
                           `3-Year ACS` = list("3-Year: Default (Detailed)" = "acs3",
                                               "3-Year: Subject" = "acs3/subject", 
                                               "3-Year: Profile" = "acs3/profile"),
                           `1-Year ACS` = list("1-Year: Default (Detailed)" = "acs1",
                                               "1-Year: Subject" = "acs1/subject", 
                                               "1-Year: Profile" = "acs1/profile"),
                           `Summary File` = list("SF: 3-Year" = "sf3", 
                                                 "SF: 1-Year" = "sf1")),
            selected = "acs5/subject")

# Year
selectInput(inputId = "states_acs_year",
            label = "Select a data endpoint year:",
            choices = c(2005:2019),
            selected = 2019)

# Variables for selection
states_acs_vars_ref <- reactive({
  
  load_variables(year = input$states_acs_year,
                 dataset = input$states_acs_dataset, 
                 cache = TRUE) %>% 
    filter(!is.na(concept)) %>% 
    mutate(table_name = gsub( "_.*$", "", name),
           label = gsub("!!", "; ", label),
           shiny_input_label = paste0(table_name, ": ", str_to_title(concept)))
  
})

# Static check
# states_acs_vars_ref <- load_variables(year = 2019,
#                                       dataset = "acs5/subject",
#                                       cache = TRUE) %>%
#   filter(!is.na(concept)) %>%
#   mutate(table_name = gsub( "_.*$", "", name),
#          label = gsub("!!", "; ", label),
#          shiny_input_label = paste0(table_name, ": ", str_to_title(concept)))

# Text for either/or option below
HTML("<p>")
h5(HTML("<b>Use either of the options below to select tables</b>"))

# Tables
renderUI({
  
  # Select dropdown
  selectizeInput(inputId = "states_acs_tables",
                 label = "1.) Select one or more tables to download:",
                 choices = split(unique(states_acs_vars_ref()$table_name),
                                 unique(states_acs_vars_ref()$shiny_input_label)),
                 selected = c("S1810", "S1811", "S2601A", "S2602"),
                 multiple = TRUE,
                 options = list(searchField = c("label", "value")))
  
  })

# File upload with variables
fileInput(inputId = "states_acs_variable_file",
          label = "Or 2.) upload a .csv file with your selected variables in the first column",
          accept = ".csv")

# Disable button based on use
observeEvent(input$states_acs_variable_file, {
  
  shinyjs::disable("states_acs_tables")
  
})

# Filter variables based on table selection or file upload
states_acs_vars_selected <- reactive({
  
  # If file has not been uploaded, base on table selection
  if (is.null(input$states_acs_variable_file)) {
    
    # Filter reference variables
    states_acs_vars_ref() %>%
      filter(table_name %in% input$states_acs_tables) %>%
      filter(!str_detect(label, pattern = "DISABILITY TYPE BY DETAILED AGE")) # Removes detailed age data
    
  }
  
  # Otherwise use uploaded file
  else {
    
    # Validate file upload
    file <- input$states_acs_variable_file
    ext <- tools::file_ext(file$datapath)

    req(file)
    validate(need(ext == "csv", "Please upload a .csv file"))
    
    # Read in file, rename first column
    file_upload <- read_csv(file$datapath) %>% 
      rename("var_name" = 1)
    
    # Filter reference variables
    states_acs_vars_ref() %>%
      filter(name %in% file_upload$var_name) %>%
      filter(!str_detect(label, pattern = "DISABILITY TYPE BY DETAILED AGE")) # Removes detailed age data
   
  }

  })

# All states and counties
fips_codes_tidy <- force(fips_codes)

```

You can review your selected tables in the table below:

```{r states-acs-variable-preview}

# State data selected
DT::renderDataTable({
  
  DT::datatable(states_acs_vars_selected(),
                rownames = FALSE,
                options = list(dom = "ft",
                               pageLength = -1,
                               scrollY = 500)) 
  
  })

```

#### **Download**

Once you are satisfied with your selection, please use the button below to submit your request to the API.

```{r states-acs-download}

# Button to run state-level ACS download code
actionButton(inputId = "states_download_button",
             label = "Click here to download state data:")

# Execute state download
acs_states_raw <- eventReactive(input$states_download_button, {
  
  # Open modal to inform user
  showModal(modalDialog("Requesting state ACS data from API...",
                        footer = NULL))
  
  # Run function
  temp <- fun_download_acs_data(geo = "state")
  
  # Remove modal
  removeModal()
  
  # Return data
  return(temp)
  
})


```

You can review your downloaded data in the table below:

```{r states-acs-data-preview}

# State data downloaded
DT::renderDataTable({

  req(acs_states_raw())

  DT::datatable(acs_states_raw() %>% head(100),
                rownames = FALSE,
                options = list(dom = "ft",
                               pageLength = -1,
                               scrollY = 500))

})

```

#### **Upload/Export**

```{r states-acs-upload}

# Button to run state-level ACS upload code
renderUI({
  
  actionButton(inputId = "states_upload_button",
               label = "Click here to upload state data to MongoDB:")
  
})

# Only enable upload when data exists
observe({
  
  shinyjs::toggleState("states_upload_button", 
                       nrow(acs_states_raw() > 0))

})

# Upload to MongoDB
observeEvent(input$states_upload_button, {
  
  # Open modal to inform user
  showModal(modalDialog("Writing state ACS data to MongoDB...",
                        footer = NULL))
  
  # Run function
  fun_write_by_geo_table(df = acs_states_raw(), 
                         host_name = config::get("host_dev"),
                         geo = "state")
  
  # Remove modal
  removeModal()
  
})

# States export button
downloadButtonRmd(outputId = "states_export_button",
                  label = "Click here to export state data to Excel:")

output$states_export_button <- downloadHandler(
  
  filename = function() {
    return("states_export_file.xlsx")
  },
  content = function(file) {
    openxlsx::write.xlsx(list("data" = acs_states_raw(),
                              "lookup" = states_acs_vars_selected() %>% 
                                select(-shiny_input_label)),
                         file)
  }
)

```

## **Cities**

### **Cities**

#### **Select Variables**

Use the following inputs to download ACS data at the city level. This script uses Kyle Walker's tidycensus package to access US Census Bureau APIs. Please consult the [tidycensus documentation](https://cran.r-project.org/web/packages/tidycensus/tidycensus.pdf) for additional information and options. 

```{r cities-acs-input}

# Dataset
selectInput(inputId = "cities_acs_dataset",
            label = "Select a dataset:",
            choices = list(`5-Year ACS` = list("5-Year: Default (Detailed)" = "acs5",
                                               "5-Year: Subject" = "acs5/subject", 
                                               "5-Year: Profile" = "acs5/profile"),
                           `3-Year ACS` = list("3-Year: Default (Detailed)" = "acs3",
                                               "3-Year: Subject" = "acs3/subject", 
                                               "3-Year: Profile" = "acs3/profile"),
                           `1-Year ACS` = list("1-Year: Default (Detailed)" = "acs1",
                                               "1-Year: Subject" = "acs1/subject", 
                                               "1-Year: Profile" = "acs1/profile"),
                           `Summary File` = list("SF: 3-Year" = "sf3", 
                                                 "SF: 1-Year" = "sf1")),
            selected = "acs5/subject")

# Year
selectInput(inputId = "cities_acs_year",
            label = "Select a data endpoint year:",
            choices = c(2005:2019),
            selected = 2019)

# Variables for selection
cities_acs_vars_ref <- reactive({
  
  load_variables(year = input$cities_acs_year,
                 dataset =  input$cities_acs_dataset, 
                 cache = TRUE) %>% 
    filter(!is.na(concept)) %>% 
    mutate(table_name = gsub( "_.*$", "", name),
           label = gsub("!!", "; ", label),
           shiny_input_label = paste0(table_name, ": ", str_to_title(concept)))
  
})

# Text for either/or option below
HTML("<p>")
h5(HTML("<b>Use either of the options below to select tables</b>"))

# Tables
renderUI({
  
  # Select dropdown
  selectizeInput(inputId = "cities_acs_tables",
                 label = "1.) Select one or more tables to download:",
                 choices = split(unique(cities_acs_vars_ref()$table_name),
                                 unique(cities_acs_vars_ref()$shiny_input_label)),
                 selected = c("S1810", "S1811", "S2601A", "S2602"),
                 multiple = TRUE,
                 options = list(searchField = c("label", "value")))
  
  })

# File upload with variables
fileInput(inputId = "cities_acs_variable_file",
          label = "Or 2.) upload a .csv file with your selected variables in the first column",
          accept = ".csv")

# Disable button based on use
observeEvent(input$cities_acs_variable_file, {
  
  shinyjs::disable("cities_acs_tables")
  
})

# Filter variables based on table selection or file upload
cities_acs_vars_selected <- reactive({
  
  # If file has not been uploaded, base on table selection
  if (is.null(input$cities_acs_variable_file)) {
    
    # Filter reference variables
    cities_acs_vars_ref() %>%
      filter(table_name %in% input$cities_acs_tables) %>%
      filter(!str_detect(label, pattern = "DISABILITY TYPE BY DETAILED AGE")) # Removes detailed age data
    
  }
  
  # Otherwise use uploaded file
  else {
    
    # Validate file upload
    file <- input$cities_acs_variable_file
    ext <- tools::file_ext(file$datapath)

    req(file)
    validate(need(ext == "csv", "Please upload a .csv file"))
    
    # Read in file, rename first column
    file_upload <- read_csv(file$datapath) %>% 
      rename("var_name" = 1)
    
    # Filter reference variables
    cities_acs_vars_ref() %>%
      filter(name %in% file_upload$var_name) %>%
      filter(!str_detect(label, pattern = "DISABILITY TYPE BY DETAILED AGE")) # Removes detailed age data
   
  }

  })

```

You can review your selected tables in the table below:

```{r cities-acs-variable-preview}

# State data selected
DT::renderDataTable({ 
  
  DT::datatable(cities_acs_vars_selected(),
                rownames = FALSE,
                options = list(dom = "ft",
                               pageLength = -1,
                               scrollY = 500)) 
  
  })

```

#### **Select Cities**

The US Census Bureau defines a "Place" as a concentration of population. This includes incorporated cities and towns, as well as unincorporated areas with no strict legal boundaries (Census-designated places or CDPs). For additional information, please consult the US Census Bureau's [Geographic Glossary](https://www.census.gov/programs-surveys/geography/about/glossary.html#par_textimage_14).

```{r cities-acs-places-input, warning=FALSE, message=FALSE}

# Pull Census places dictionary from GitHub repo
cities_acs_places_ref <- read_csv("https://raw.githubusercontent.com/sean-connelly/ADA-PARC-Website-Design/national-tile-map/dictionaries/dict_places.txt") %>% 
  filter(!is.na(POP))

# Text for either/or option below
HTML("<p>")
h5(HTML("<b>Use either of the options below to select cities</b>"))

# City dropdown
selectizeInput(inputId = "cities_acs_places",
               label = "1.) Select one or more cities:",
               choices = tibble::deframe(cities_acs_places_ref %>%
                                           arrange(desc(POP)) %>% 
                                           select(metro_state, GEOID)),
               multiple = TRUE)

# Reference list for download
HTML("<b>Or 2.) upload a .csv file with your selected cities' Census GEOIDs in the first column</b>")

# Download button
downloadButtonRmd(outputId = "download_cities_ref_file",
                  label = "Download CSV of cities for reference")

output$download_cities_ref_file <- downloadHandler(
  
  filename = function() {
    return("cities_reference_file.csv")
  },
  content = function(file) {
    write.csv(cities_acs_places_ref %>%
                select("census_GEOID" = GEOID, "census_NAME" = NAME,
                       metro_state,
                       "population" = POP, "density" = DENSITY), 
              file, row.names = FALSE)
  }
)

# File upload with cities
HTML("<p>")
fileInput(inputId = "cities_acs_places_file",
          label = "Upload .csv file",
          accept = ".csv")

# Disable button based on use
observeEvent(input$cities_acs_places_file, {
  
  shinyjs::disable("cities_acs_places")
  
})

# Filter places based on table selection or file upload
cities_acs_places_selected <- reactive({
  
  # If file has not been uploaded, base on table selection
  if (is.null(input$cities_acs_places_file)) {
    
    # Filter reference variables
    cities_acs_places_ref %>%
      filter(GEOID %in% input$cities_acs_places)
    
  }
  
  # Otherwise use uploaded file
  else {
    
    # Validate file upload
    file <- input$cities_acs_places_file
    ext <- tools::file_ext(file$datapath)

    req(file)
    validate(need(ext == "csv", "Please upload a .csv file"))
    
    # Read in file, rename first column
    file_upload <- read_csv(file$datapath) %>% 
      rename("GEOID" = 1) %>% 
      mutate("GEOID" = as.character(GEOID) %>% 
               stringr::str_pad(7, side = "left", pad = "0"))
    
    # Filter reference variables
    cities_acs_places_ref %>%
      filter(GEOID %in% file_upload$GEOID)
   
  }

  })

# Static check
# cities_acs_places_selected <- read_csv("example_cities_geoid_upload.csv") %>% 
#   rename("GEOID" = 1) %>% 
#   mutate("GEOID" = as.character(GEOID))


```

You can review your selected cities in the table below:

```{r cities-acs-places-preview}

# City data selected
DT::renderDataTable({ 
  
  DT::datatable(cities_acs_places_selected() %>%
                  arrange(desc(POP)) %>%  
                  select(GEOID, 
                         "City" = metro_state,
                         "Pop." = POP),
                rownames = FALSE,
                options = list(dom = "ft",
                               pageLength = -1,
                               scrollY = 500)) %>% 
    DT::formatCurrency(columns = "Pop.", currency = "", digits = 0)
  
  })

```

#### **Download**

Once you are satisfied with your selection, please use the button below to submit your request to the API.

```{r cities-acs-download}

# Button to run state-level ACS download code
actionButton(inputId = "cities_download_button",
             label = "Click here to download city/place data:")

# Execute state download
acs_cities_raw <- eventReactive(input$cities_download_button, {
  
  # Open modal to inform user
  showModal(modalDialog("Requesting city/place ACS data from API...",
                        footer = NULL))
  
  # Run function
  temp <- fun_download_acs_data(geo = "place")
  
  # Remove modal
  removeModal()
  
  # Return data
  return(temp)
  
})

```

You can review your downloaded data in the table below:

```{r cities-acs-data-preview}

# State data downloaded
DT::renderDataTable({

  req(acs_cities_raw())

  DT::datatable(acs_cities_raw() %>% head(100),
                rownames = FALSE,
                options = list(dom = "ft",
                               pageLength = -1,
                               scrollY = 500))

})

```

#### **Upload/Export**

```{r cities-acs-upload}

# Button to run city-level ACS upload code
renderUI({
  
  actionButton(inputId = "cities_upload_button",
               label = "Click here to upload city/place data to MongoDB:")
  
})

# Only enable upload when data exists
observe({
  
  shinyjs::toggleState("cities_upload_button", 
                       nrow(acs_cities_raw() > 0))

})

# Upload to MongoDB
observeEvent(input$cities_upload_button, {
  
  # Open modal to inform user
  showModal(modalDialog("Writing place/city ACS data to MongoDB...",
                        footer = NULL))
  
  # Run function
  fun_write_by_geo_table(df = acs_cities_raw(), 
                         host_name = config::get("host_dev"),
                         geo = "place")
  
  # Remove modal
  removeModal()
  
})

# Cities export button
downloadButtonRmd(outputId = "cities_export_button",
                  label = "Click here to export city/place data to Excel:")

output$cities_export_button <- downloadHandler(
  
  filename = function() {
    return("cities_export_file.xlsx")
  },
  content = function(file) {
    openxlsx::write.xlsx(list("data" = acs_cities_raw(),
                              "lookup" = cities_acs_vars_selected() %>% 
                                select(-shiny_input_label)),
                         file)
  }
)

```

### **Tracts**

#### **Select ACS Components**

```{r tracts-acs-input}

# Dataset
selectInput(inputId = "tracts_acs_dataset",
            label = "Select a dataset:",
            choices = list(`5-Year ACS` = list("5-Year: Default (Detailed)" = "acs5",
                                               "5-Year: Subject" = "acs5/subject", 
                                               "5-Year: Profile" = "acs5/profile"),
                           `3-Year ACS` = list("3-Year: Default (Detailed)" = "acs3",
                                               "3-Year: Subject" = "acs3/subject", 
                                               "3-Year: Profile" = "acs3/profile"),
                           `1-Year ACS` = list("1-Year: Default (Detailed)" = "acs1",
                                               "1-Year: Subject" = "acs1/subject", 
                                               "1-Year: Profile" = "acs1/profile"),
                           `Summary File` = list("SF: 3-Year" = "sf3", 
                                                 "SF: 1-Year" = "sf1")),
            selected = "acs5/subject")

# Year
selectInput(inputId = "tracts_acs_year",
            label = "Select a data endpoint year:",
            choices = c(2005:2019),
            selected = 2019)

# Variables for selection
tracts_acs_vars_ref <- reactive({
  
  load_variables(year = input$tracts_acs_year,
                 dataset = input$tracts_acs_dataset, 
                 cache = TRUE) %>% 
    filter(!is.na(concept)) %>% 
    mutate("table_name" = gsub( "_.*$", "", name),
           "label" = gsub("!!", "; ", label),
           "shiny_input_label" = paste0(table_name, ": ", str_to_title(concept)))
  
})

# Text for either/or option below
HTML("<p>")
h5(HTML("<b>Use either of the options below to select tables</b>"))

# Tables
renderUI({
  
  # Select dropdown
  selectizeInput(inputId = "tracts_acs_tables",
                 label = "1.) Select one or more tables to download:",
                 choices = split(unique(tracts_acs_vars_ref()$table_name),
                                 unique(tracts_acs_vars_ref()$shiny_input_label)),
                 selected = c("S1810", "S1811"),
                 multiple = TRUE,
                 options = list(searchField = c("label", "value")))
  
  })

# File upload with variables
fileInput(inputId = "tracts_acs_variable_file",
          label = "Or 2.) upload a .csv file with your selected variables in the first column",
          accept = ".csv")

# Disable button based on use
observeEvent(input$tracts_acs_variable_file, {
  
  shinyjs::disable("tracts_acs_tables")
  
})

# Filter variables based on table selection or file upload
tracts_acs_vars_selected <- reactive({
  
  # If file has not been uploaded, base on table selection
  if (is.null(input$tracts_acs_variable_file)) {
    
    # Filter reference variables
    tracts_acs_vars_ref() %>%
      filter(table_name %in% input$tracts_acs_tables) %>%
      filter(!str_detect(label, pattern = "DISABILITY TYPE BY DETAILED AGE")) # Removes detailed age data
    
  }
  
  # Otherwise use uploaded file
  else {
    
    # Validate file upload
    file <- input$tracts_acs_variable_file
    ext <- tools::file_ext(file$datapath)

    req(file)
    validate(need(ext == "csv", "Please upload a .csv file"))
    
    # Read in file, rename first column
    file_upload <- read_csv(file$datapath) %>% 
      rename("var_name" = 1)
    
    # Filter reference variables
    tracts_acs_vars_ref() %>%
      filter(name %in% file_upload$var_name) %>%
      filter(!str_detect(label, pattern = "DISABILITY TYPE BY DETAILED AGE")) # Removes detailed age data
   
  }

  })

```

You can review your selected tables in the table below:

```{r tracts-acs-variable-preview}

# State data selected
DT::renderDataTable({ 
  
  DT::datatable(tracts_acs_vars_selected(),
                rownames = FALSE,
                options = list(dom = "ft",
                               pageLength = -1,
                               scrollY = 500)) 
  
  })

```


#### **Select Census Tracts**

The US Census Bureau defines a "Census Tract" as a small, relatively permanent statistical subdivision of a county that generally has a population size of 1,200 and 8,000 people, with an optimum size of 4,000 people. These generally trace legal (e.g. city limits) and physical (e.g. major streets, rivers, etc.) boundaries. For additional information, please consult the US Census Bureau's [Geographic Glossary](https://www.census.gov/programs-surveys/geography/about/glossary.html#par_textimage_13).

Census Tracts are available by state and county. To access tract data, please ensure that you have filled out the "Select Cities" section above.

```{r tracts-acs-location-input, message=FALSE}

# Pull city/county/tract dictionary from GitHub repo 
# Set minimum overlap threshold, default units [m^2]
tracts_places_counties <- reactive({ 
  
  read_csv("https://raw.githubusercontent.com/sean-connelly/ADA-PARC-Website-Design/national-tile-map/dictionaries/dict_location_crosswalk.txt") %>%
    filter(county_place_overlap_pct > 0,
           place_GEOID %in% c(cities_acs_places_selected()$GEOID))
    
})

```

You can review your selected state and county pairings in the table below:

```{r tracts-acs-location-preview}

# City/state/county combinations for tract data
DT::renderDataTable({ 
  
  DT::datatable(tracts_places_counties() %>%
                  select(metro_state, county_NAME) %>% 
                  distinct() %>% 
                  group_by("City" = metro_state) %>% 
                  summarize("Counties" = str_c(county_NAME, 
                                            collapse = ", ")),
                rownames = FALSE,
                options = list(dom = "ft",
                               pageLength = -1,
                               scrollY = 500))
  
})

```

#### **Download ACS Data**

Once you are satisfied with your selection, please use the button below to submit your request to the API.

```{r tracts-acs-download}

# Button to run state-level ACS download code
actionButton(inputId = "tracts_download_button",
             label = "Click here to download Census Tract data:")

# Execute state download
acs_tracts_raw <- eventReactive(input$tracts_download_button, {
  
  # Open modal to inform user
  showModal(modalDialog("Requesting Census Tract ACS data from API...",
                        footer = NULL))
  
  # Run function
  temp <- fun_download_acs_data(geo = "tract")
  
  # Remove modal
  removeModal()
  
  # Return data
  return(temp)
  
})

```

You can review your downloaded data in the table below:

```{r tracts-acs-data-preview}

# State data downloaded
DT::renderDataTable({

  req(acs_tracts_raw())

  DT::datatable(acs_tracts_raw()[["data"]] %>% head(100),
                rownames = FALSE,
                options = list(dom = "ft",
                               pageLength = -1,
                               scrollY = 500))

})

```

#### **Upload/Export**

```{r tracts-acs-upload}

# Button to run tract-level ACS upload code
renderUI({
  
  actionButton(inputId = "tracts_upload_button",
               label = "Click here to upload tract data to MongoDB:")
  
})

# Only enable upload when data exists
observe({
  
  shinyjs::toggleState("tracts_upload_button", 
                       nrow(acs_tracts_raw()[["data"]] > 0))

})

# Upload to MongoDB
observeEvent(input$tracts_upload_button, {
  
  # Open modal to inform user
  showModal(modalDialog("Writing tract ACS data to MongoDB...",
                        footer = NULL))
  
  # Run function
  fun_write_by_geo_table(df = acs_tracts_raw()[["data"]], 
                         host_name = config::get("host_dev"),
                         geo = "tract")
  
  # Upload geographies
  # Connect to MongoDB database/collection
  mongo_conn <- fun_mongo_connect(host_name = config::get("host_dev"),
                                  collection_name = "geo_tract",
                                  database_name = "ADA-PARC")
  
  # Write to database and add spatial index
  temp_geo <- geojsonsf::sf_geojson(acs_tracts_raw()[["geography"]], 
                                    atomise = TRUE) 
  mongo_conn$drop()
  mongo_conn$insert(temp_geo)
  mongo_conn$index((add = '{"geometry" : "2dsphere"}'))
  
  # Disconnect
  rm(temp_geo)
  rm(mongo_conn)

  # Remove modal
  removeModal()
  
})

# tracts export button
downloadButtonRmd(outputId = "tracts_export_button",
                  label = "Click here to export tract data to a ZIP file:")

output$tracts_export_button <- downloadHandler(
  
  filename = function() {
    return("tracts_export_files.zip")
  },
  content = function(file) {
    
    # Files
    tmpdir <- tempdir()
    setwd(tempdir())
    files = c("tracts_export_data.xlsx",
              "tracts_export_geography.shp")
    
    # Excel worksheet
    openxlsx::write.xlsx(list("data" = acs_tracts_raw()[["data"]],
                              "lookup" = tracts_acs_vars_selected() %>% 
                                select(-shiny_input_label)),
                         "tracts_export_data.xlsx")
    
    # Shapefile
    sf::st_write(acs_tracts_raw()[["geography"]],
                 "tracts_export_geography.shp",
                 delete_dsn = TRUE)
    
    # ZIP
    zip("tracts_export_files.zip", files)
    # system2("zip", 
    #         args = paste("tracts_export_files.zip",
    #                      files,
    #                      sep = " "))
    if(file.exists(paste0(file, ".zip"))) {
      file.rename(paste0(file, ".zip"), file)}
    
  },
  contentType = "application/zip"
)

```

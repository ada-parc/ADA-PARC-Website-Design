---
title: "ADA-PARC Census Database Builder Tool"
output:
  html_document:
    toc: TRUE
    toc_float: TRUE
    toc_depth: 6
    code_folding: hide
editor_options: 
  chunk_output_type: console
runtime: shiny
---

```{r setup, include=FALSE}

# Libraries
library(tidyverse);library(readxl)
library(tigris);library(sf);library(janitor)
library(tidycensus);library(viridis);library(tmap)
library(RPostgres);library(RPostgreSQL);library(DBI)
library(geojsonsf);library(mongolite)
library(shiny);library(shinyjs);library(shinyWidgets)

# Set working document, options
setwd(here::here())
options(stringsAsFactors = FALSE, scipen = 999, dplyr.summarise.inform = FALSE, tigris_use_cache = TRUE)
knitr::opts_chunk$set(echo = FALSE)

# Load API keys and database connection information
source("secret.R", local = TRUE)

```

### **Background**

This interactive walkthrough tool allows users to upload specific American Community Survey (ACS) data related to people with disabilities to the MongoDB database powering the [ADA-PARC Data Dashboard](https://ada-parc.shinyapps.io/ada_parc/). The rest of the document is organized by the various geographies used in the ADA-PARC dashboard: States, Cities (or Places), and Tracts.

### **States**

#### **Select ACS Components**

Use the following inputs to download ACS data at the state level. This script uses Kyle Walker's tidycensus package to access US Census Bureau APIs. Please consult the [tidycensus documentation](https://cran.r-project.org/web/packages/tidycensus/tidycensus.pdf) for additional information and options. 

```{r states-acs-input}

# Dataset
selectInput(inputId = "states_acs_dataset",
            label = "Select a dataset:",
            choices = list(`5-Year ACS` = list("Default (Detailed)" = "acs5",
                                               "Subject" = "acs5/subject", 
                                               "Profile" = "acs5/profile"),
                           `3-Year ACS` = list("Default (Detailed)" = "acs3",
                                               "Subject" = "acs3/subject", 
                                               "Profile" = "acs3/profile"),
                           `1-Year ACS` = list("Default (Detailed)" = "acs1",
                                               "Subject" = "acs1/subject", 
                                               "Profile" = "acs1/profile"),
                           `Summary File` = list("3-Year" = "sf3", 
                                                 "1-Year" = "sf1")),
            selected = "acs5/subject")

# Year
selectInput(inputId = "states_acs_year",
            label = "Select a data endpoint year:",
            choices = c(2005:2019),
            selected = 2019)

# Variables for selection
states_acs_vars_ref <- reactive({
  
  load_variables(year = input$states_acs_year,
                 dataset =  input$states_acs_dataset, 
                 cache = TRUE) %>% 
    filter(!is.na(concept)) %>% 
    mutate(table_name = gsub( "_.*$", "", name),
           label = gsub("!!", "; ", label),
           shiny_input_label = paste0(table_name, ": ", str_to_title(concept)))
  
})

# Static check
# states_acs_vars_ref <- load_variables(year = 2019,
#                                       dataset = "acs5/subject",
#                                       cache = TRUE) %>%
#   filter(!is.na(concept)) %>%
#   mutate(table_name = gsub( "_.*$", "", name),
#          label = gsub("!!", "; ", label),
#          shiny_input_label = paste0(table_name, ": ", str_to_title(concept)))

# Tables
renderUI({
  
  selectizeInput(inputId = "states_acs_tables",
                 label = "Select one or more tables to download:",
                 choices = split(unique(states_acs_vars_ref()$table_name),
                                 unique(states_acs_vars_ref()$shiny_input_label)),
                 selected = c("S1810", "S1811", "S2601A", "S2602"),
                 multiple = TRUE,
                 options = list(searchField = c("label", "value")))
  
  })

# File upload with variables
fileInput(inputId = "states_acs_variable_file",
          label = "Or upload a .csv file with your selected variables in the first column",
          accept = ".csv")

# Filter variables based on table selection or file upload
states_acs_vars_selected <- reactive({
  
  # If file has not been uploaded, base on table selection
  if (is.null(input$states_acs_variable_file)) {
    
    # Filter reference variables
    states_acs_vars_ref() %>%
      filter(table_name %in% input$states_acs_tables) %>%
      filter(!str_detect(label, pattern = "DISABILITY TYPE BY DETAILED AGE")) # Removes detailed age data
    
  }
  
  # Otherwise use uploaded file
  else {
    
    # Validate file upload
    file <- input$states_acs_variable_file
    ext <- tools::file_ext(file$datapath)

    req(file)
    validate(need(ext == "csv", "Please upload a .csv file"))
    
    # Read in file, rename first column
    file_upload <- read_csv(file$datapath, header = TRUE) %>% 
      rename("var_name" = 1)
    
    # Filter reference variables
    states_acs_vars_ref() %>%
      filter(name %in% file_upload$var_name) %>%
      filter(!str_detect(label, pattern = "DISABILITY TYPE BY DETAILED AGE")) # Removes detailed age data
   
  }
  
  })

# All states and counties
fips_codes <- force(fips_codes) %>% 
  mutate("state_code_num" = as.numeric(state_code)) %>% 
  distinct(state, state_code, county_code)

```

You can review your selected tables in the table below:

```{r states-acs-variable-preview}

# State data selected
DT::renderDataTable({ DT::datatable(states_acs_vars_selected(),
                                    rownames = FALSE,
                                    options = list(dom = "ft",
                                                   pageLength = -1,
                                                   scrollY = 500)) })

```

#### **Download ACS Data**

Once you are satisfied with your selection, please use the button below to submit your request to the API.

```{r states-acs-download}

# Button to run state-level ACS download code
actionButton(inputId = "states_download_button",
             label = "Click here to download state data:")

# Function for ACS download
fun_download_acs_data <- function(geo) {
  
  # ===============
  # Define intermediate variables
  # ===============
  
  # Year
  temp_year <- reactive({

    case_when(geo == "state" ~
                as.numeric(input$states_acs_year),
              TRUE ~ 2019)

  })

  message(paste0("Year = ", as.character(temp_year())))
  
  # Survey
  temp_survey <- reactive({

    case_when(geo == "state" ~
                coalesce(str_extract(input$states_acs_dataset,
                                     pattern = "^.*(?=/)"),
                         input$states_acs_dataset),
              TRUE ~ "acs5")

  })

  message(paste0("Survey = ", temp_survey()))
  
  # ACS variables
  acs_vars_selected <- reactive({ 
    
    case_when(geo == "state" ~
                states_acs_vars_selected() %>% 
                pull(name),
              TRUE ~ 
                states_acs_vars_selected() %>% 
                pull(name)) 
    
  })
  
  # Geometry  
  temp_geometry <- case_when(geo == "state" ~
                               FALSE,
                             TRUE ~ FALSE)
  
  message(paste0("Geometry = ", as.character(temp_geometry)))
          
  # Wide
  temp_wide <- case_when(geo == "state" ~
                           TRUE,
                         TRUE ~ TRUE)
  
  message(paste0("Wide = ", as.character(temp_wide)))
  
  # ===============
  # Download ACS data
  # ===============
  
  # Grab from API 
  message(paste0("Starting API Call"))
  
  acs_raw <- reactive({
    
    get_acs(geography = geo,
            year = temp_year(),
            variables = acs_vars_selected(),
            survey = temp_survey(),
            geometry = temp_geometry,
            wide = temp_wide)
    
    # Static check (state)
    # get_acs(geography = "state",
    #         year = 2019,
    #         variables = states_acs_vars_selected() %>% pull(name),
    #         survey = "acs5",
    #         geometry = temp_geometry,
    #         wide = temp_wide)
        
  })

  # # Clean and restructure 
  # acs_clean <- reactive({
  #   
  #   if (geo == "state") {
  #   
  #   # Standardize variable names for MongoDB
  #     temp <- acs_raw() %>% 
  #       mutate(variable = gsub("PR", "", variable)) %>%
  #       left_join(fips_codes %>% select(state, state_code), 
  #                 by = c("GEOID" = "state_code")) %>%
  #       relocate(state, .after = NAME) %>%
  #       distinct()
  #   
  # # } else if (geo == "place") { 
  #   
  # } else { #tracts
  #   
  # }
  #   
  #   return(temp)
  #   
  # })
  
  return(acs_raw())
  
}

# Execute state download
acs_state_raw <- eventReactive(input$states_download_button, {
  
  # Open modal to inform user
  showModal(modalDialog("Requesting state ACS data from API...",
                        footer = NULL))
  
  # Run function
  temp <- fun_download_acs_data(geo = "state")
  
  # Remove modal
  removeModal()
  
  # Return data
  return(temp)
  
})


```

You can review your downloaded data in the table below:

```{r states-acs-data-preview}

# State data downloaded
DT::renderDataTable({

  req(acs_state_raw())

  DT::datatable(acs_state_raw() %>% head(100),
                rownames = FALSE,
                options = list(dom = "ft",
                               pageLength = -1,
                               scrollY = 500))

})

```

#### **Upload ACS Data to MongoDB**

```{r states-acs-upload}

# Button to run state-level ACS upload code
renderUI({
  
  actionButton(inputId = "states_upload_button",
               label = "Click here to upload state data to MongoDB:")
  
})

# Only enable upload when data exists
observe({
  
  shinyjs::toggleState("states_upload_button", nrow(acs_state_raw() > 0))

})

# Function for ACS download

```

### Cities

#### Select ACS Components

You can also embed plots, for example:

#### Select Cities (Census-Defined Places) 

```{r cities-location-input}

# most_populated <- get_estimates(geography = "place",
#                                 year = 2018,
#                                 product = "population",
#                                 geometry = FALSE,
#                                 output = "wide") %>% 
#   arrange(desc(POP)) %>% 
#   head(200)

```
